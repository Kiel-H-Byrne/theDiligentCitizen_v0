[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                       //\n// packages/overture8_wordcloud2/packages/overture8_wordcloud2.js                        //\n//                                                                                       //\n///////////////////////////////////////////////////////////////////////////////////////////\n                                                                                         //\n(function () {                                                                           // 1\n                                                                                         // 2\n///////////////////////////////////////////////////////////////////////////////////      // 3\n//                                                                               //      // 4\n// packages/overture8:wordcloud2/wordcloud2.js                                   //      // 5\n//                                                                               //      // 6\n///////////////////////////////////////////////////////////////////////////////////      // 7\n                                                                                 //      // 8\n/*!                                                                              // 1    // 9\n * wordcloud2.js                                                                 // 2    // 10\n * http://timdream.org/wordcloud2.js/                                            // 3    // 11\n *                                                                               // 4    // 12\n * Copyright 2011 - 2013 Tim Chien                                               // 5    // 13\n * Released under the MIT license                                                // 6    // 14\n */                                                                              // 7    // 15\n                                                                                 // 8    // 16\n'use strict';                                                                    // 9    // 17\n                                                                                 // 10   // 18\n// setImmediate                                                                  // 11   // 19\nif (!window.setImmediate) {                                                      // 12   // 20\n  window.setImmediate = (function setupSetImmediate() {                          // 13   // 21\n    return window.msSetImmediate ||                                              // 14   // 22\n    window.webkitSetImmediate ||                                                 // 15   // 23\n    window.mozSetImmediate ||                                                    // 16   // 24\n    window.oSetImmediate ||                                                      // 17   // 25\n    (function setupSetZeroTimeout() {                                            // 18   // 26\n      if (!window.postMessage || !window.addEventListener) {                     // 19   // 27\n        return null;                                                             // 20   // 28\n      }                                                                          // 21   // 29\n                                                                                 // 22   // 30\n      var callbacks = [undefined];                                               // 23   // 31\n      var message = 'zero-timeout-message';                                      // 24   // 32\n                                                                                 // 25   // 33\n      // Like setTimeout, but only takes a function argument.  There's           // 26   // 34\n      // no time argument (always zero) and no arguments (you have to            // 27   // 35\n      // use a closure).                                                         // 28   // 36\n      var setZeroTimeout = function setZeroTimeout(callback) {                   // 29   // 37\n        var id = callbacks.length;                                               // 30   // 38\n        callbacks.push(callback);                                                // 31   // 39\n        window.postMessage(message + id.toString(36), '*');                      // 32   // 40\n                                                                                 // 33   // 41\n        return id;                                                               // 34   // 42\n      };                                                                         // 35   // 43\n                                                                                 // 36   // 44\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {   // 37   // 45\n        // Skipping checking event source, retarded IE confused this window      // 38   // 46\n        // object with another in the presence of iframe                         // 39   // 47\n        if (typeof evt.data !== 'string' ||                                      // 40   // 48\n            evt.data.substr(0, message.length) !== message/* ||                  // 41   // 49\n            evt.source !== window */) {                                          // 42   // 50\n          return;                                                                // 43   // 51\n        }                                                                        // 44   // 52\n                                                                                 // 45   // 53\n        evt.stopImmediatePropagation();                                          // 46   // 54\n                                                                                 // 47   // 55\n        var id = parseInt(evt.data.substr(message.length), 36);                  // 48   // 56\n        if (!callbacks[id]) {                                                    // 49   // 57\n          return;                                                                // 50   // 58\n        }                                                                        // 51   // 59\n                                                                                 // 52   // 60\n        callbacks[id]();                                                         // 53   // 61\n        callbacks[id] = undefined;                                               // 54   // 62\n      }, true);                                                                  // 55   // 63\n                                                                                 // 56   // 64\n      /* specify clearImmediate() here since we need the scope */                // 57   // 65\n      window.clearImmediate = function clearZeroTimeout(id) {                    // 58   // 66\n        if (!callbacks[id]) {                                                    // 59   // 67\n          return;                                                                // 60   // 68\n        }                                                                        // 61   // 69\n                                                                                 // 62   // 70\n        callbacks[id] = undefined;                                               // 63   // 71\n      };                                                                         // 64   // 72\n                                                                                 // 65   // 73\n      return setZeroTimeout;                                                     // 66   // 74\n    })() ||                                                                      // 67   // 75\n    // fallback                                                                  // 68   // 76\n    function setImmediateFallback(fn) {                                          // 69   // 77\n      window.setTimeout(fn, 0);                                                  // 70   // 78\n    };                                                                           // 71   // 79\n  })();                                                                          // 72   // 80\n}                                                                                // 73   // 81\n                                                                                 // 74   // 82\nif (!window.clearImmediate) {                                                    // 75   // 83\n  window.clearImmediate = (function setupClearImmediate() {                      // 76   // 84\n    return window.msClearImmediate ||                                            // 77   // 85\n    window.webkitClearImmediate ||                                               // 78   // 86\n    window.mozClearImmediate ||                                                  // 79   // 87\n    window.oClearImmediate ||                                                    // 80   // 88\n    // \"clearZeroTimeout\" is implement on the previous block ||                  // 81   // 89\n    // fallback                                                                  // 82   // 90\n    function clearImmediateFallback(timer) {                                     // 83   // 91\n      window.clearTimeout(timer);                                                // 84   // 92\n    };                                                                           // 85   // 93\n  })();                                                                          // 86   // 94\n}                                                                                // 87   // 95\n                                                                                 // 88   // 96\n(function(global) {                                                              // 89   // 97\n                                                                                 // 90   // 98\n  // Check if WordCloud can run on this browser                                  // 91   // 99\n  var isSupported = (function isSupported() {                                    // 92   // 100\n    var canvas = document.createElement('canvas');                               // 93   // 101\n    if (!canvas || !canvas.getContext) {                                         // 94   // 102\n      return false;                                                              // 95   // 103\n    }                                                                            // 96   // 104\n                                                                                 // 97   // 105\n    var ctx = canvas.getContext('2d');                                           // 98   // 106\n    if (!ctx.getImageData) {                                                     // 99   // 107\n      return false;                                                              // 100  // 108\n    }                                                                            // 101  // 109\n    if (!ctx.fillText) {                                                         // 102  // 110\n      return false;                                                              // 103  // 111\n    }                                                                            // 104  // 112\n                                                                                 // 105  // 113\n    if (!Array.prototype.some) {                                                 // 106  // 114\n      return false;                                                              // 107  // 115\n    }                                                                            // 108  // 116\n    if (!Array.prototype.push) {                                                 // 109  // 117\n      return false;                                                              // 110  // 118\n    }                                                                            // 111  // 119\n                                                                                 // 112  // 120\n    return true;                                                                 // 113  // 121\n  }());                                                                          // 114  // 122\n                                                                                 // 115  // 123\n  // Find out if the browser impose minium font size by                          // 116  // 124\n  // drawing small texts on a canvas and measure it's width.                     // 117  // 125\n  var miniumFontSize = (function getMiniumFontSize() {                           // 118  // 126\n    if (!isSupported) {                                                          // 119  // 127\n      return;                                                                    // 120  // 128\n    }                                                                            // 121  // 129\n                                                                                 // 122  // 130\n    var ctx = document.createElement('canvas').getContext('2d');                 // 123  // 131\n                                                                                 // 124  // 132\n    // start from 20                                                             // 125  // 133\n    var size = 20;                                                               // 126  // 134\n                                                                                 // 127  // 135\n    // two sizes to measure                                                      // 128  // 136\n    var hanWidth, mWidth;                                                        // 129  // 137\n                                                                                 // 130  // 138\n    while (size) {                                                               // 131  // 139\n      ctx.font = size.toString(10) + 'px sans-serif';                            // 132  // 140\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&                      // 133  // 141\n          (ctx.measureText('m').width) === mWidth) {                             // 134  // 142\n        return (size + 1);                                                       // 135  // 143\n      }                                                                          // 136  // 144\n                                                                                 // 137  // 145\n      hanWidth = ctx.measureText('\\uFF37').width;                                // 138  // 146\n      mWidth = ctx.measureText('m').width;                                       // 139  // 147\n                                                                                 // 140  // 148\n      size--;                                                                    // 141  // 149\n    }                                                                            // 142  // 150\n                                                                                 // 143  // 151\n    return 0;                                                                    // 144  // 152\n  })();                                                                          // 145  // 153\n                                                                                 // 146  // 154\n  // Based on http://jsfromhell.com/array/shuffle                                // 147  // 155\n  var shuffleArray = function shuffleArray(arr) {                                // 148  // 156\n    for (var j, x, i = arr.length; i;                                            // 149  // 157\n      j = Math.floor(Math.random() * i),                                         // 150  // 158\n      x = arr[--i], arr[i] = arr[j],                                             // 151  // 159\n      arr[j] = x) {}                                                             // 152  // 160\n    return arr;                                                                  // 153  // 161\n  };                                                                             // 154  // 162\n                                                                                 // 155  // 163\n  var WordCloud = function WordCloud(elements, options) {                        // 156  // 164\n    if (!isSupported) {                                                          // 157  // 165\n      return;                                                                    // 158  // 166\n    }                                                                            // 159  // 167\n                                                                                 // 160  // 168\n    if (!Array.isArray(elements)) {                                              // 161  // 169\n      elements = [elements];                                                     // 162  // 170\n    }                                                                            // 163  // 171\n                                                                                 // 164  // 172\n    elements.forEach(function(el, i) {                                           // 165  // 173\n      if (typeof el === 'string') {                                              // 166  // 174\n        elements[i] = document.getElementById(el);                               // 167  // 175\n        if (!elements[i]) {                                                      // 168  // 176\n          throw 'The element id specified is not found.';                        // 169  // 177\n        }                                                                        // 170  // 178\n      } else if (!el.tagName && !el.appendChild) {                               // 171  // 179\n        throw 'You must pass valid HTML elements, or ID of the element.';        // 172  // 180\n      }                                                                          // 173  // 181\n    });                                                                          // 174  // 182\n                                                                                 // 175  // 183\n    /* Default values to be overwritten by options object */                     // 176  // 184\n    var settings = {                                                             // 177  // 185\n      list: [],                                                                  // 178  // 186\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +                      // 179  // 187\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',       // 180  // 188\n      fontWeight: 'normal',                                                      // 181  // 189\n      color: 'random-dark',                                                      // 182  // 190\n      minSize: 0, // 0 to disable                                                // 183  // 191\n      weightFactor: 1,                                                           // 184  // 192\n      clearCanvas: true,                                                         // 185  // 193\n      backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)         // 186  // 194\n                                                                                 // 187  // 195\n      gridSize: 8,                                                               // 188  // 196\n      origin: null,                                                              // 189  // 197\n                                                                                 // 190  // 198\n      drawMask: false,                                                           // 191  // 199\n      maskColor: 'rgba(255,0,0,0.3)',                                            // 192  // 200\n      maskGapWidth: 0.3,                                                         // 193  // 201\n                                                                                 // 194  // 202\n      wait: 0,                                                                   // 195  // 203\n      abortThreshold: 0, // disabled                                             // 196  // 204\n      abort: function noop() {},                                                 // 197  // 205\n                                                                                 // 198  // 206\n      minRotation: - Math.PI / 2,                                                // 199  // 207\n      maxRotation: Math.PI / 2,                                                  // 200  // 208\n                                                                                 // 201  // 209\n      shuffle: true,                                                             // 202  // 210\n      rotateRatio: 0.1,                                                          // 203  // 211\n                                                                                 // 204  // 212\n      shape: 'circle',                                                           // 205  // 213\n      ellipticity: 0.65,                                                         // 206  // 214\n                                                                                 // 207  // 215\n      hover: null,                                                               // 208  // 216\n      click: null                                                                // 209  // 217\n    };                                                                           // 210  // 218\n                                                                                 // 211  // 219\n    if (options) {                                                               // 212  // 220\n      for (var key in options) {                                                 // 213  // 221\n        if (key in settings) {                                                   // 214  // 222\n          settings[key] = options[key];                                          // 215  // 223\n        }                                                                        // 216  // 224\n      }                                                                          // 217  // 225\n    }                                                                            // 218  // 226\n                                                                                 // 219  // 227\n    /* Convert weightFactor into a function */                                   // 220  // 228\n    if (typeof settings.weightFactor !== 'function') {                           // 221  // 229\n      var factor = settings.weightFactor;                                        // 222  // 230\n      settings.weightFactor = function weightFactor(pt) {                        // 223  // 231\n        return pt * factor; //in px                                              // 224  // 232\n      };                                                                         // 225  // 233\n    }                                                                            // 226  // 234\n                                                                                 // 227  // 235\n    /* Convert shape into a function */                                          // 228  // 236\n    if (typeof settings.shape !== 'function') {                                  // 229  // 237\n      switch (settings.shape) {                                                  // 230  // 238\n        case 'circle':                                                           // 231  // 239\n        /* falls through */                                                      // 232  // 240\n        default:                                                                 // 233  // 241\n          // 'circle' is the default and a shortcut in the code loop.            // 234  // 242\n          settings.shape = 'circle';                                             // 235  // 243\n          break;                                                                 // 236  // 244\n                                                                                 // 237  // 245\n        case 'cardioid':                                                         // 238  // 246\n          settings.shape = function shapeCardioid(theta) {                       // 239  // 247\n            return 1 - Math.sin(theta);                                          // 240  // 248\n          };                                                                     // 241  // 249\n          break;                                                                 // 242  // 250\n                                                                                 // 243  // 251\n        /*                                                                       // 244  // 252\n                                                                                 // 245  // 253\n        To work out an X-gon, one has to calculate \"m\",                          // 246  // 254\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))                // 247  // 255\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28 // 248  // 256\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29                   // 249  // 257\n                                                                                 // 250  // 258\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))        // 251  // 259\n        where t' equals to mod(t, 2PI/X);                                        // 252  // 260\n                                                                                 // 253  // 261\n        */                                                                       // 254  // 262\n                                                                                 // 255  // 263\n        case 'diamond':                                                          // 256  // 264\n        case 'square':                                                           // 257  // 265\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+   // 258  // 266\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D   // 259  // 267\n          // +0+..+2*PI                                                          // 260  // 268\n          settings.shape = function shapeSquare(theta) {                         // 261  // 269\n            var thetaPrime = theta % (2 * Math.PI / 4);                          // 262  // 270\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));            // 263  // 271\n          };                                                                     // 264  // 272\n          break;                                                                 // 265  // 273\n                                                                                 // 266  // 274\n        case 'triangle-forward':                                                 // 267  // 275\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+   // 268  // 276\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29   // 269  // 277\n          // %29%29%2C+t+%3D+0+..+2*PI                                           // 270  // 278\n          settings.shape = function shapeTriangle(theta) {                       // 271  // 279\n            var thetaPrime = theta % (2 * Math.PI / 3);                          // 272  // 280\n            return 1 / (Math.cos(thetaPrime) +                                   // 273  // 281\n                        Math.sqrt(3) * Math.sin(thetaPrime));                    // 274  // 282\n          };                                                                     // 275  // 283\n          break;                                                                 // 276  // 284\n                                                                                 // 277  // 285\n        case 'triangle':                                                         // 278  // 286\n        case 'triangle-upright':                                                 // 279  // 287\n          settings.shape = function shapeTriangle(theta) {                       // 280  // 288\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);      // 281  // 289\n            return 1 / (Math.cos(thetaPrime) +                                   // 282  // 290\n                        Math.sqrt(3) * Math.sin(thetaPrime));                    // 283  // 291\n          };                                                                     // 284  // 292\n          break;                                                                 // 285  // 293\n                                                                                 // 286  // 294\n        case 'pentagon':                                                         // 287  // 295\n          settings.shape = function shapePentagon(theta) {                       // 288  // 296\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);                // 289  // 297\n            return 1 / (Math.cos(thetaPrime) +                                   // 290  // 298\n                        0.726543 * Math.sin(thetaPrime));                        // 291  // 299\n          };                                                                     // 292  // 300\n          break;                                                                 // 293  // 301\n                                                                                 // 294  // 302\n        case 'star':                                                             // 295  // 303\n          settings.shape = function shapeStar(theta) {                           // 296  // 304\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);               // 297  // 305\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) { // 298  // 306\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +            // 299  // 307\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));  // 300  // 308\n            } else {                                                             // 301  // 309\n              return 1 / (Math.cos(thetaPrime) +                                 // 302  // 310\n                          3.07768 * Math.sin(thetaPrime));                       // 303  // 311\n            }                                                                    // 304  // 312\n          };                                                                     // 305  // 313\n          break;                                                                 // 306  // 314\n      }                                                                          // 307  // 315\n    }                                                                            // 308  // 316\n                                                                                 // 309  // 317\n    /* Make sure gridSize is a whole number and is not smaller than 4px */       // 310  // 318\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);              // 311  // 319\n                                                                                 // 312  // 320\n    /* shorthand */                                                              // 313  // 321\n    var g = settings.gridSize;                                                   // 314  // 322\n    var maskRectWidth = g - settings.maskGapWidth;                               // 315  // 323\n                                                                                 // 316  // 324\n    /* normalize rotation settings */                                            // 317  // 325\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);   // 318  // 326\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);      // 319  // 327\n                                                                                 // 320  // 328\n    /* information/object available to all functions, set when start() */        // 321  // 329\n    var grid, // 2d array containing filling information                         // 322  // 330\n      ngx, ngy, // width and height of the grid                                  // 323  // 331\n      center, // position of the center of the cloud                             // 324  // 332\n      maxRadius;                                                                 // 325  // 333\n                                                                                 // 326  // 334\n    /* timestamp for measuring each putWord() action */                          // 327  // 335\n    var escapeTime;                                                              // 328  // 336\n                                                                                 // 329  // 337\n    /* function for getting the color of the text */                             // 330  // 338\n    var getTextColor;                                                            // 331  // 339\n    switch (settings.color) {                                                    // 332  // 340\n      case 'random-dark':                                                        // 333  // 341\n        getTextColor = function getRandomDarkColor() {                           // 334  // 342\n          return 'rgb(' +                                                        // 335  // 343\n            Math.floor(Math.random() * 128).toString(10) + ',' +                 // 336  // 344\n            Math.floor(Math.random() * 128).toString(10) + ',' +                 // 337  // 345\n            Math.floor(Math.random() * 128).toString(10) + ')';                  // 338  // 346\n        };                                                                       // 339  // 347\n        break;                                                                   // 340  // 348\n                                                                                 // 341  // 349\n      case 'random-light':                                                       // 342  // 350\n        getTextColor = function getRandomLightColor() {                          // 343  // 351\n          return 'rgb(' +                                                        // 344  // 352\n            Math.floor(Math.random() * 128 + 128).toString(10) + ',' +           // 345  // 353\n            Math.floor(Math.random() * 128 + 128).toString(10) + ',' +           // 346  // 354\n            Math.floor(Math.random() * 128 + 128).toString(10) + ')';            // 347  // 355\n        };                                                                       // 348  // 356\n        break;                                                                   // 349  // 357\n                                                                                 // 350  // 358\n      default:                                                                   // 351  // 359\n        if (typeof settings.color === 'function') {                              // 352  // 360\n          getTextColor = settings.color;                                         // 353  // 361\n        }                                                                        // 354  // 362\n        break;                                                                   // 355  // 363\n    }                                                                            // 356  // 364\n                                                                                 // 357  // 365\n    /* Interactive */                                                            // 358  // 366\n    var interactive = false;                                                     // 359  // 367\n    var infoGrid = [];                                                           // 360  // 368\n    var hovered;                                                                 // 361  // 369\n                                                                                 // 362  // 370\n    var getInfoGridFromMouseEvent = function getInfoGridFromMouseEvent(evt) {    // 363  // 371\n      var canvas = evt.currentTarget;                                            // 364  // 372\n      var rect = canvas.getBoundingClientRect();                                 // 365  // 373\n      var eventX = evt.clientX - rect.left;                                      // 366  // 374\n      var eventY = evt.clientY - rect.top;                                       // 367  // 375\n                                                                                 // 368  // 376\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);       // 369  // 377\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);     // 370  // 378\n                                                                                 // 371  // 379\n      return infoGrid[x][y];                                                     // 372  // 380\n    };                                                                           // 373  // 381\n                                                                                 // 374  // 382\n    var wordcloudhover = function wordcloudhover(evt) {                          // 375  // 383\n      var info = getInfoGridFromMouseEvent(evt);                                 // 376  // 384\n                                                                                 // 377  // 385\n      if (hovered === info) {                                                    // 378  // 386\n        return;                                                                  // 379  // 387\n      }                                                                          // 380  // 388\n                                                                                 // 381  // 389\n      hovered = info;                                                            // 382  // 390\n      if (!info) {                                                               // 383  // 391\n        settings.hover(undefined, undefined, evt);                               // 384  // 392\n                                                                                 // 385  // 393\n        return;                                                                  // 386  // 394\n      }                                                                          // 387  // 395\n                                                                                 // 388  // 396\n      settings.hover(info.item, info.dimension, evt);                            // 389  // 397\n                                                                                 // 390  // 398\n    };                                                                           // 391  // 399\n                                                                                 // 392  // 400\n    var wordcloudclick = function wordcloudclick(evt) {                          // 393  // 401\n      var info = getInfoGridFromMouseEvent(evt);                                 // 394  // 402\n      if (!info) {                                                               // 395  // 403\n        return;                                                                  // 396  // 404\n      }                                                                          // 397  // 405\n                                                                                 // 398  // 406\n      settings.click(info.item, info.dimension, evt);                            // 399  // 407\n    };                                                                           // 400  // 408\n                                                                                 // 401  // 409\n    /* Get points on the grid for a given radius away from the center */         // 402  // 410\n    var pointsAtRadius = [];                                                     // 403  // 411\n    var getPointsAtRadius = function getPointsAtRadius(radius) {                 // 404  // 412\n      if (pointsAtRadius[radius]) {                                              // 405  // 413\n        return pointsAtRadius[radius];                                           // 406  // 414\n      }                                                                          // 407  // 415\n                                                                                 // 408  // 416\n      // Look for these number of points on each radius                          // 409  // 417\n      var T = radius * 8;                                                        // 410  // 418\n                                                                                 // 411  // 419\n      // Getting all the points at this radius                                   // 412  // 420\n      var t = T;                                                                 // 413  // 421\n      var points = [];                                                           // 414  // 422\n                                                                                 // 415  // 423\n      if (radius === 0) {                                                        // 416  // 424\n        points.push([center[0], center[1], 0]);                                  // 417  // 425\n      }                                                                          // 418  // 426\n                                                                                 // 419  // 427\n      while (t--) {                                                              // 420  // 428\n        // distort the radius to put the cloud in shape                          // 421  // 429\n        var rx = 1;                                                              // 422  // 430\n        if (settings.shape !== 'circle') {                                       // 423  // 431\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1                    // 424  // 432\n        }                                                                        // 425  // 433\n                                                                                 // 426  // 434\n        // Push [x, y, t]; t is used solely for getTextColor()                   // 427  // 435\n        points.push([                                                            // 428  // 436\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),              // 429  // 437\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *             // 430  // 438\n            settings.ellipticity,                                                // 431  // 439\n          t / T * 2 * Math.PI]);                                                 // 432  // 440\n      }                                                                          // 433  // 441\n                                                                                 // 434  // 442\n      pointsAtRadius[radius] = points;                                           // 435  // 443\n      return points;                                                             // 436  // 444\n    };                                                                           // 437  // 445\n                                                                                 // 438  // 446\n    /* Return true if we had spent too much time */                              // 439  // 447\n    var exceedTime = function exceedTime() {                                     // 440  // 448\n      return ((settings.abortThreshold > 0) &&                                   // 441  // 449\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold));        // 442  // 450\n    };                                                                           // 443  // 451\n                                                                                 // 444  // 452\n    /* Get the deg of rotation according to settings, and luck. */               // 445  // 453\n    var getRotateDeg = function getRotateDeg() {                                 // 446  // 454\n      if (settings.rotateRatio === 0) {                                          // 447  // 455\n        return 0;                                                                // 448  // 456\n      }                                                                          // 449  // 457\n                                                                                 // 450  // 458\n      if (Math.random() > settings.rotateRatio) {                                // 451  // 459\n        return 0;                                                                // 452  // 460\n      }                                                                          // 453  // 461\n                                                                                 // 454  // 462\n      if (rotationRange === 0) {                                                 // 455  // 463\n        return minRotation;                                                      // 456  // 464\n      }                                                                          // 457  // 465\n                                                                                 // 458  // 466\n      return minRotation + Math.random() * rotationRange;                        // 459  // 467\n    };                                                                           // 460  // 468\n                                                                                 // 461  // 469\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {            // 462  // 470\n      // calculate the acutal font size                                          // 463  // 471\n      // fontSize === 0 means weightFactor function wants the text skipped,      // 464  // 472\n      // and size < minSize means we cannot draw the text.                       // 465  // 473\n      var debug = false;                                                         // 466  // 474\n      var fontSize = settings.weightFactor(weight);                              // 467  // 475\n      if (fontSize <= settings.minSize) {                                        // 468  // 476\n        return false;                                                            // 469  // 477\n      }                                                                          // 470  // 478\n                                                                                 // 471  // 479\n      // Scale factor here is to make sure fillText is not limited by            // 472  // 480\n      // the minium font size set by browser.                                    // 473  // 481\n      // It will always be 1 or 2n.                                              // 474  // 482\n      var mu = 1;                                                                // 475  // 483\n      if (fontSize < miniumFontSize) {                                           // 476  // 484\n        mu = (function calculateScaleFactor() {                                  // 477  // 485\n          var mu = 2;                                                            // 478  // 486\n          while (mu * fontSize < miniumFontSize) {                               // 479  // 487\n            mu += 2;                                                             // 480  // 488\n          }                                                                      // 481  // 489\n          return mu;                                                             // 482  // 490\n        })();                                                                    // 483  // 491\n      }                                                                          // 484  // 492\n                                                                                 // 485  // 493\n      var fcanvas = document.createElement('canvas');                            // 486  // 494\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });         // 487  // 495\n                                                                                 // 488  // 496\n      fctx.font = settings.fontWeight + ' ' +                                    // 489  // 497\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;              // 490  // 498\n                                                                                 // 491  // 499\n      // Estimate the dimension of the text with measureText().                  // 492  // 500\n      var fw = fctx.measureText(word).width / mu;                                // 493  // 501\n      var fh = Math.max(fontSize * mu,                                           // 494  // 502\n                        fctx.measureText('m').width,                             // 495  // 503\n                        fctx.measureText('\\uFF37').width) / mu;                  // 496  // 504\n                                                                                 // 497  // 505\n      // Create a boundary box that is larger than our estimates,                // 498  // 506\n      // so text don't get cut of (it sill might)                                // 499  // 507\n      var boxWidth = fw + fh * 2;                                                // 500  // 508\n      var boxHeight = fh * 3;                                                    // 501  // 509\n      var fgw = Math.ceil(boxWidth / g);                                         // 502  // 510\n      var fgh = Math.ceil(boxHeight / g);                                        // 503  // 511\n      boxWidth = fgw * g;                                                        // 504  // 512\n      boxHeight = fgh * g;                                                       // 505  // 513\n                                                                                 // 506  // 514\n      // Calculate the proper offsets to make the text centered at               // 507  // 515\n      // the preferred position.                                                 // 508  // 516\n                                                                                 // 509  // 517\n      // This is simply half of the width.                                       // 510  // 518\n      var fillTextOffsetX = - fw / 2;                                            // 511  // 519\n      // Instead of moving the box to the exact middle of the preferred          // 512  // 520\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look     // 513  // 521\n      // vertical centered.                                                      // 514  // 522\n      var fillTextOffsetY = - fh * 0.4;                                          // 515  // 523\n                                                                                 // 516  // 524\n      // Calculate the actual dimension of the canvas, considering the rotation. // 517  // 525\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +            // 518  // 526\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);      // 519  // 527\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +            // 520  // 528\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);      // 521  // 529\n      var width = cgw * g;                                                       // 522  // 530\n      var height = cgh * g;                                                      // 523  // 531\n                                                                                 // 524  // 532\n      fcanvas.setAttribute('width', width);                                      // 525  // 533\n      fcanvas.setAttribute('height', height);                                    // 526  // 534\n                                                                                 // 527  // 535\n      if (debug) {                                                               // 528  // 536\n        // Attach fcanvas to the DOM                                             // 529  // 537\n        document.body.appendChild(fcanvas);                                      // 530  // 538\n        // Save it's state so that we could restore and draw the grid correctly. // 531  // 539\n        fctx.save();                                                             // 532  // 540\n      }                                                                          // 533  // 541\n                                                                                 // 534  // 542\n      // Scale the canvas with |mu|.                                             // 535  // 543\n      fctx.scale(1 / mu, 1 / mu);                                                // 536  // 544\n      fctx.translate(width * mu / 2, height * mu / 2);                           // 537  // 545\n      fctx.rotate(- rotateDeg);                                                  // 538  // 546\n                                                                                 // 539  // 547\n      // Once the width/height is set, ctx info will be reset.                   // 540  // 548\n      // Set it again here.                                                      // 541  // 549\n      fctx.font = settings.fontWeight + ' ' +                                    // 542  // 550\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;              // 543  // 551\n                                                                                 // 544  // 552\n      // Fill the text into the fcanvas.                                         // 545  // 553\n      // XXX: We cannot because textBaseline = 'top' here because                // 546  // 554\n      // Firefox and Chrome uses different default line-height for canvas.       // 547  // 555\n      // Please read https://bugzil.la/737852#c6.                                // 548  // 556\n      // Here, we use textBaseline = 'middle' and draw the text at exactly       // 549  // 557\n      // 0.5 * fontSize lower.                                                   // 550  // 558\n      fctx.fillStyle = '#000';                                                   // 551  // 559\n      fctx.textBaseline = 'middle';                                              // 552  // 560\n      fctx.fillText(word, fillTextOffsetX * mu,                                  // 553  // 561\n                    (fillTextOffsetY + fontSize * 0.5) * mu);                    // 554  // 562\n                                                                                 // 555  // 563\n      // Get the pixels of the text                                              // 556  // 564\n      var imageData = fctx.getImageData(0, 0, width, height).data;               // 557  // 565\n                                                                                 // 558  // 566\n      if (exceedTime()) {                                                        // 559  // 567\n        return false;                                                            // 560  // 568\n      }                                                                          // 561  // 569\n                                                                                 // 562  // 570\n      if (debug) {                                                               // 563  // 571\n        // Draw the box of the original estimation                               // 564  // 572\n        fctx.strokeRect(fillTextOffsetX * mu,                                    // 565  // 573\n                        fillTextOffsetY, fw * mu, fh * mu);                      // 566  // 574\n        fctx.restore();                                                          // 567  // 575\n      }                                                                          // 568  // 576\n                                                                                 // 569  // 577\n      // Read the pixels and save the information to the occupied array          // 570  // 578\n      var occupied = [];                                                         // 571  // 579\n      var gx = cgw, gy, x, y;                                                    // 572  // 580\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];                         // 573  // 581\n      while (gx--) {                                                             // 574  // 582\n        gy = cgh;                                                                // 575  // 583\n        while (gy--) {                                                           // 576  // 584\n          y = g;                                                                 // 577  // 585\n          singleGridLoop: {                                                      // 578  // 586\n            while (y--) {                                                        // 579  // 587\n              x = g;                                                             // 580  // 588\n              while (x--) {                                                      // 581  // 589\n                if (imageData[((gy * g + y) * width +                            // 582  // 590\n                               (gx * g + x)) * 4 + 3]) {                         // 583  // 591\n                  occupied.push([gx, gy]);                                       // 584  // 592\n                                                                                 // 585  // 593\n                  if (gx < bounds[3]) {                                          // 586  // 594\n                    bounds[3] = gx;                                              // 587  // 595\n                  }                                                              // 588  // 596\n                  if (gx > bounds[1]) {                                          // 589  // 597\n                    bounds[1] = gx;                                              // 590  // 598\n                  }                                                              // 591  // 599\n                  if (gy < bounds[0]) {                                          // 592  // 600\n                    bounds[0] = gy;                                              // 593  // 601\n                  }                                                              // 594  // 602\n                  if (gy > bounds[2]) {                                          // 595  // 603\n                    bounds[2] = gy;                                              // 596  // 604\n                  }                                                              // 597  // 605\n                                                                                 // 598  // 606\n                  if (debug) {                                                   // 599  // 607\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';                     // 600  // 608\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);             // 601  // 609\n                  }                                                              // 602  // 610\n                  break singleGridLoop;                                          // 603  // 611\n                }                                                                // 604  // 612\n              }                                                                  // 605  // 613\n            }                                                                    // 606  // 614\n            if (debug) {                                                         // 607  // 615\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';                           // 608  // 616\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);                   // 609  // 617\n            }                                                                    // 610  // 618\n          }                                                                      // 611  // 619\n        }                                                                        // 612  // 620\n      }                                                                          // 613  // 621\n                                                                                 // 614  // 622\n      if (debug) {                                                               // 615  // 623\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';                                 // 616  // 624\n        fctx.fillRect(bounds[3] * g,                                             // 617  // 625\n                      bounds[0] * g,                                             // 618  // 626\n                      (bounds[1] - bounds[3] + 1) * g,                           // 619  // 627\n                      (bounds[2] - bounds[0] + 1) * g);                          // 620  // 628\n      }                                                                          // 621  // 629\n                                                                                 // 622  // 630\n      // Return information needed to create the text on the real canvas         // 623  // 631\n      return {                                                                   // 624  // 632\n        mu: mu,                                                                  // 625  // 633\n        occupied: occupied,                                                      // 626  // 634\n        bounds: bounds,                                                          // 627  // 635\n        gw: cgw,                                                                 // 628  // 636\n        gh: cgh,                                                                 // 629  // 637\n        fillTextOffsetX: fillTextOffsetX,                                        // 630  // 638\n        fillTextOffsetY: fillTextOffsetY,                                        // 631  // 639\n        fillTextWidth: fw,                                                       // 632  // 640\n        fillTextHeight: fh,                                                      // 633  // 641\n        fontSize: fontSize                                                       // 634  // 642\n      };                                                                         // 635  // 643\n    };                                                                           // 636  // 644\n                                                                                 // 637  // 645\n    /* Determine if there is room available in the given dimension */            // 638  // 646\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {             // 639  // 647\n      // Go through the occupied points,                                         // 640  // 648\n      // return false if the space is not available.                             // 641  // 649\n      var i = occupied.length;                                                   // 642  // 650\n      while (i--) {                                                              // 643  // 651\n        var px = gx + occupied[i][0];                                            // 644  // 652\n        var py = gy + occupied[i][1];                                            // 645  // 653\n                                                                                 // 646  // 654\n        if (px >= ngx || py >= ngy || px < 0 || py < 0 || !grid[px][py]) {       // 647  // 655\n          return false;                                                          // 648  // 656\n        }                                                                        // 649  // 657\n      }                                                                          // 650  // 658\n      return true;                                                               // 651  // 659\n    };                                                                           // 652  // 660\n                                                                                 // 653  // 661\n    /* Actually draw the text on the grid */                                     // 654  // 662\n    var drawText = function drawText(gx, gy, info, word, weight,                 // 655  // 663\n                                     distance, theta, rotateDeg, attributes) {   // 656  // 664\n                                                                                 // 657  // 665\n      var fontSize = info.fontSize;                                              // 658  // 666\n      var color;                                                                 // 659  // 667\n      if (getTextColor) {                                                        // 660  // 668\n        color = getTextColor(word, weight, fontSize, distance, theta);           // 661  // 669\n      } else {                                                                   // 662  // 670\n        color = settings.color;                                                  // 663  // 671\n      }                                                                          // 664  // 672\n                                                                                 // 665  // 673\n      var dimension;                                                             // 666  // 674\n      var bounds = info.bounds;                                                  // 667  // 675\n      dimension = {                                                              // 668  // 676\n        x: (gx + bounds[3]) * g,                                                 // 669  // 677\n        y: (gy + bounds[0]) * g,                                                 // 670  // 678\n        w: (bounds[1] - bounds[3] + 1) * g,                                      // 671  // 679\n        h: (bounds[2] - bounds[0] + 1) * g                                       // 672  // 680\n      };                                                                         // 673  // 681\n                                                                                 // 674  // 682\n      elements.forEach(function(el) {                                            // 675  // 683\n        if (el.getContext) {                                                     // 676  // 684\n          var ctx = el.getContext('2d');                                         // 677  // 685\n          var mu = info.mu;                                                      // 678  // 686\n                                                                                 // 679  // 687\n          // Save the current state before messing it                            // 680  // 688\n          ctx.save();                                                            // 681  // 689\n          ctx.scale(1 / mu, 1 / mu);                                             // 682  // 690\n                                                                                 // 683  // 691\n          ctx.font = settings.fontWeight + ' ' +                                 // 684  // 692\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // 685  // 693\n          ctx.fillStyle = color;                                                 // 686  // 694\n                                                                                 // 687  // 695\n          // Translate the canvas position to the origin coordinate of where     // 688  // 696\n          // the text should be put.                                             // 689  // 697\n          ctx.translate((gx + info.gw / 2) * g * mu,                             // 690  // 698\n                        (gy + info.gh / 2) * g * mu);                            // 691  // 699\n                                                                                 // 692  // 700\n          if (rotateDeg !== 0) {                                                 // 693  // 701\n            ctx.rotate(- rotateDeg);                                             // 694  // 702\n          }                                                                      // 695  // 703\n                                                                                 // 696  // 704\n          // Finally, fill the text.                                             // 697  // 705\n                                                                                 // 698  // 706\n          // XXX: We cannot because textBaseline = 'top' here because            // 699  // 707\n          // Firefox and Chrome uses different default line-height for canvas.   // 700  // 708\n          // Please read https://bugzil.la/737852#c6.                            // 701  // 709\n          // Here, we use textBaseline = 'middle' and draw the text at exactly   // 702  // 710\n          // 0.5 * fontSize lower.                                               // 703  // 711\n          ctx.textBaseline = 'middle';                                           // 704  // 712\n          ctx.fillText(word, info.fillTextOffsetX * mu,                          // 705  // 713\n                             (info.fillTextOffsetY + fontSize * 0.5) * mu);      // 706  // 714\n                                                                                 // 707  // 715\n          // The below box is always matches how <span>s are positioned          // 708  // 716\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,          // 709  // 717\n            info.fillTextWidth, info.fillTextHeight); */                         // 710  // 718\n                                                                                 // 711  // 719\n          // Restore the state.                                                  // 712  // 720\n          ctx.restore();                                                         // 713  // 721\n        } else {                                                                 // 714  // 722\n          // drawText on DIV element                                             // 715  // 723\n          var span = document.createElement('span');                             // 716  // 724\n          var transformRule = '';                                                // 717  // 725\n          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';   // 718  // 726\n          if (info.mu !== 1) {                                                   // 719  // 727\n            transformRule +=                                                     // 720  // 728\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +               // 721  // 729\n              'scale(' + (1 / info.mu) + ')';                                    // 722  // 730\n          }                                                                      // 723  // 731\n          var styleRules = {                                                     // 724  // 732\n            'position': 'absolute',                                              // 725  // 733\n            'display': 'block',                                                  // 726  // 734\n            'font': settings.fontWeight + ' ' +                                  // 727  // 735\n                    (fontSize * info.mu) + 'px ' + settings.fontFamily,          // 728  // 736\n            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',      // 729  // 737\n            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',       // 730  // 738\n            'width': info.fillTextWidth + 'px',                                  // 731  // 739\n            'height': info.fillTextHeight + 'px',                                // 732  // 740\n            'color': color,                                                      // 733  // 741\n            'lineHeight': fontSize + 'px',                                       // 734  // 742\n            'whiteSpace': 'nowrap',                                              // 735  // 743\n            'transform': transformRule,                                          // 736  // 744\n            'webkitTransform': transformRule,                                    // 737  // 745\n            'msTransform': transformRule,                                        // 738  // 746\n            'transformOrigin': '50% 40%',                                        // 739  // 747\n            'webkitTransformOrigin': '50% 40%',                                  // 740  // 748\n            'msTransformOrigin': '50% 40%'                                       // 741  // 749\n          };                                                                     // 742  // 750\n          span.textContent = word;                                               // 743  // 751\n          for (var cssProp in styleRules) {                                      // 744  // 752\n            span.style[cssProp] = styleRules[cssProp];                           // 745  // 753\n          }                                                                      // 746  // 754\n          if (attributes) {                                                      // 747  // 755\n            for (var attribute in attributes) {                                  // 748  // 756\n              span.setAttribute(attribute, attributes[attribute]);               // 749  // 757\n            }                                                                    // 750  // 758\n          }                                                                      // 751  // 759\n          el.appendChild(span);                                                  // 752  // 760\n        }                                                                        // 753  // 761\n      });                                                                        // 754  // 762\n    };                                                                           // 755  // 763\n                                                                                 // 756  // 764\n    /* Help function to updateGrid */                                            // 757  // 765\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {      // 758  // 766\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {                              // 759  // 767\n        return;                                                                  // 760  // 768\n      }                                                                          // 761  // 769\n                                                                                 // 762  // 770\n      grid[x][y] = false;                                                        // 763  // 771\n                                                                                 // 764  // 772\n      if (drawMask) {                                                            // 765  // 773\n        var ctx = elements[0].getContext('2d');                                  // 766  // 774\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);                // 767  // 775\n      }                                                                          // 768  // 776\n                                                                                 // 769  // 777\n      if (interactive) {                                                         // 770  // 778\n        infoGrid[x][y] = { item: item, dimension: dimension };                   // 771  // 779\n      }                                                                          // 772  // 780\n    };                                                                           // 773  // 781\n                                                                                 // 774  // 782\n    /* Update the filling information of the given space with occupied points.   // 775  // 783\n       Draw the mask on the canvas if necessary. */                              // 776  // 784\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {           // 777  // 785\n      var occupied = info.occupied;                                              // 778  // 786\n      var drawMask = settings.drawMask;                                          // 779  // 787\n      var ctx;                                                                   // 780  // 788\n      if (drawMask) {                                                            // 781  // 789\n        ctx = elements[0].getContext('2d');                                      // 782  // 790\n        ctx.save();                                                              // 783  // 791\n        ctx.fillStyle = settings.maskColor;                                      // 784  // 792\n      }                                                                          // 785  // 793\n                                                                                 // 786  // 794\n      var dimension;                                                             // 787  // 795\n      if (interactive) {                                                         // 788  // 796\n        var bounds = info.bounds;                                                // 789  // 797\n        dimension = {                                                            // 790  // 798\n          x: (gx + bounds[3]) * g,                                               // 791  // 799\n          y: (gy + bounds[0]) * g,                                               // 792  // 800\n          w: (bounds[1] - bounds[3] + 1) * g,                                    // 793  // 801\n          h: (bounds[2] - bounds[0] + 1) * g                                     // 794  // 802\n        };                                                                       // 795  // 803\n      }                                                                          // 796  // 804\n                                                                                 // 797  // 805\n      var i = occupied.length;                                                   // 798  // 806\n      while (i--) {                                                              // 799  // 807\n        fillGridAt(gx + occupied[i][0], gy + occupied[i][1],                     // 800  // 808\n                   drawMask, dimension, item);                                   // 801  // 809\n      }                                                                          // 802  // 810\n                                                                                 // 803  // 811\n      if (drawMask) {                                                            // 804  // 812\n        ctx.restore();                                                           // 805  // 813\n      }                                                                          // 806  // 814\n    };                                                                           // 807  // 815\n                                                                                 // 808  // 816\n    /* putWord() processes each item on the list,                                // 809  // 817\n       calculate it's size and determine it's position, and actually             // 810  // 818\n       put it on the canvas. */                                                  // 811  // 819\n    var putWord = function putWord(item) {                                       // 812  // 820\n      var word, weight, attributes;                                              // 813  // 821\n      if (Array.isArray(item)) {                                                 // 814  // 822\n        word = item[0];                                                          // 815  // 823\n        weight = item[1];                                                        // 816  // 824\n      } else {                                                                   // 817  // 825\n        word = item.word;                                                        // 818  // 826\n        weight = item.weight;                                                    // 819  // 827\n        attributes = item.attributes;                                            // 820  // 828\n      }                                                                          // 821  // 829\n      var rotateDeg = getRotateDeg();                                            // 822  // 830\n                                                                                 // 823  // 831\n      // get info needed to put the text onto the canvas                         // 824  // 832\n      var info = getTextInfo(word, weight, rotateDeg);                           // 825  // 833\n                                                                                 // 826  // 834\n      // not getting the info means we shouldn't be drawing this one.            // 827  // 835\n      if (!info) {                                                               // 828  // 836\n        return false;                                                            // 829  // 837\n      }                                                                          // 830  // 838\n                                                                                 // 831  // 839\n      if (exceedTime()) {                                                        // 832  // 840\n        return false;                                                            // 833  // 841\n      }                                                                          // 834  // 842\n                                                                                 // 835  // 843\n      // Skip the loop if we have already know the bounding box of               // 836  // 844\n      // word is larger than the canvas.                                         // 837  // 845\n      var bounds = info.bounds;                                                  // 838  // 846\n      if ((bounds[1] - bounds[3] + 1) > ngx ||                                   // 839  // 847\n        (bounds[2] - bounds[0] + 1) > ngy) {                                     // 840  // 848\n        return false;                                                            // 841  // 849\n      }                                                                          // 842  // 850\n                                                                                 // 843  // 851\n      // Determine the position to put the text by                               // 844  // 852\n      // start looking for the nearest points                                    // 845  // 853\n      var r = maxRadius + 1;                                                     // 846  // 854\n                                                                                 // 847  // 855\n      var tryToPutWordAtPoint = function(gxy) {                                  // 848  // 856\n        var gx = Math.floor(gxy[0] - info.gw / 2);                               // 849  // 857\n        var gy = Math.floor(gxy[1] - info.gh / 2);                               // 850  // 858\n        var gw = info.gw;                                                        // 851  // 859\n        var gh = info.gh;                                                        // 852  // 860\n                                                                                 // 853  // 861\n        // If we cannot fit the text at this position, return false              // 854  // 862\n        // and go to the next position.                                          // 855  // 863\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {                        // 856  // 864\n          return false;                                                          // 857  // 865\n        }                                                                        // 858  // 866\n                                                                                 // 859  // 867\n        // Actually put the text on the canvas                                   // 860  // 868\n        drawText(gx, gy, info, word, weight,                                     // 861  // 869\n                 (maxRadius - r), gxy[2], rotateDeg, attributes);                // 862  // 870\n                                                                                 // 863  // 871\n        // Mark the spaces on the grid as filled                                 // 864  // 872\n        updateGrid(gx, gy, gw, gh, info, item);                                  // 865  // 873\n                                                                                 // 866  // 874\n        // Return true so some() will stop and also return true.                 // 867  // 875\n        return true;                                                             // 868  // 876\n      };                                                                         // 869  // 877\n                                                                                 // 870  // 878\n      while (r--) {                                                              // 871  // 879\n        var points = getPointsAtRadius(maxRadius - r);                           // 872  // 880\n                                                                                 // 873  // 881\n        if (settings.shuffle) {                                                  // 874  // 882\n          points = [].concat(points);                                            // 875  // 883\n          shuffleArray(points);                                                  // 876  // 884\n        }                                                                        // 877  // 885\n                                                                                 // 878  // 886\n        // Try to fit the words by looking at each point.                        // 879  // 887\n        // array.some() will stop and return true                                // 880  // 888\n        // when putWordAtPoint() returns true.                                   // 881  // 889\n        // If all the points returns false, array.some() returns false.          // 882  // 890\n        var drawn = points.some(tryToPutWordAtPoint);                            // 883  // 891\n                                                                                 // 884  // 892\n        if (drawn) {                                                             // 885  // 893\n          // leave putWord() and return true                                     // 886  // 894\n          return true;                                                           // 887  // 895\n        }                                                                        // 888  // 896\n      }                                                                          // 889  // 897\n      // we tried all distances but text won't fit, return false                 // 890  // 898\n      return false;                                                              // 891  // 899\n    };                                                                           // 892  // 900\n                                                                                 // 893  // 901\n    /* Send DOM event to all elements. Will stop sending event and return        // 894  // 902\n       if the previous one is canceled (for cancelable events). */               // 895  // 903\n    var sendEvent = function sendEvent(type, cancelable, detail) {               // 896  // 904\n      if (cancelable) {                                                          // 897  // 905\n        return !elements.some(function(el) {                                     // 898  // 906\n          var evt = document.createEvent('CustomEvent');                         // 899  // 907\n          evt.initCustomEvent(type, true, cancelable, detail || {});             // 900  // 908\n          return !el.dispatchEvent(evt);                                         // 901  // 909\n        }, this);                                                                // 902  // 910\n      } else {                                                                   // 903  // 911\n        elements.forEach(function(el) {                                          // 904  // 912\n          var evt = document.createEvent('CustomEvent');                         // 905  // 913\n          evt.initCustomEvent(type, true, cancelable, detail || {});             // 906  // 914\n          el.dispatchEvent(evt);                                                 // 907  // 915\n        }, this);                                                                // 908  // 916\n      }                                                                          // 909  // 917\n    };                                                                           // 910  // 918\n                                                                                 // 911  // 919\n    /* Start drawing on a canvas */                                              // 912  // 920\n    var start = function start() {                                               // 913  // 921\n      // For dimensions, clearCanvas etc.,                                       // 914  // 922\n      // we only care about the first element.                                   // 915  // 923\n      var canvas = elements[0];                                                  // 916  // 924\n                                                                                 // 917  // 925\n      if (canvas.getContext) {                                                   // 918  // 926\n        ngx = Math.floor(canvas.width / g);                                      // 919  // 927\n        ngy = Math.floor(canvas.height / g);                                     // 920  // 928\n      } else {                                                                   // 921  // 929\n        var rect = canvas.getBoundingClientRect();                               // 922  // 930\n        ngx = Math.floor(rect.width / g);                                        // 923  // 931\n        ngy = Math.floor(rect.height / g);                                       // 924  // 932\n      }                                                                          // 925  // 933\n                                                                                 // 926  // 934\n      // Sending a wordcloudstart event which cause the previous loop to stop.   // 927  // 935\n      // Do nothing if the event is canceled.                                    // 928  // 936\n      if (!sendEvent('wordcloudstart', true)) {                                  // 929  // 937\n        return;                                                                  // 930  // 938\n      }                                                                          // 931  // 939\n                                                                                 // 932  // 940\n      // Determine the center of the word cloud                                  // 933  // 941\n      center = (settings.origin) ?                                               // 934  // 942\n        [settings.origin[0]/g, settings.origin[1]/g] :                           // 935  // 943\n        [ngx / 2, ngy / 2];                                                      // 936  // 944\n                                                                                 // 937  // 945\n      // Maxium radius to look for space                                         // 938  // 946\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));                  // 939  // 947\n                                                                                 // 940  // 948\n      /* Clear the canvas only if the clearCanvas is set,                        // 941  // 949\n         if not, update the grid to the current canvas state */                  // 942  // 950\n      grid = [];                                                                 // 943  // 951\n                                                                                 // 944  // 952\n      var gx, gy, i;                                                             // 945  // 953\n      if (!canvas.getContext || settings.clearCanvas) {                          // 946  // 954\n        elements.forEach(function(el) {                                          // 947  // 955\n          if (el.getContext) {                                                   // 948  // 956\n            var ctx = el.getContext('2d');                                       // 949  // 957\n            ctx.fillStyle = settings.backgroundColor;                            // 950  // 958\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));                   // 951  // 959\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));                    // 952  // 960\n          } else {                                                               // 953  // 961\n            el.textContent = '';                                                 // 954  // 962\n            el.style.backgroundColor = settings.backgroundColor;                 // 955  // 963\n          }                                                                      // 956  // 964\n        });                                                                      // 957  // 965\n                                                                                 // 958  // 966\n        /* fill the grid with empty state */                                     // 959  // 967\n        gx = ngx;                                                                // 960  // 968\n        while (gx--) {                                                           // 961  // 969\n          grid[gx] = [];                                                         // 962  // 970\n          gy = ngy;                                                              // 963  // 971\n          while (gy--) {                                                         // 964  // 972\n            grid[gx][gy] = true;                                                 // 965  // 973\n          }                                                                      // 966  // 974\n        }                                                                        // 967  // 975\n      } else {                                                                   // 968  // 976\n        /* Determine bgPixel by creating                                         // 969  // 977\n           another canvas and fill the specified background color. */            // 970  // 978\n        var bctx = document.createElement('canvas').getContext('2d');            // 971  // 979\n                                                                                 // 972  // 980\n        bctx.fillStyle = settings.backgroundColor;                               // 973  // 981\n        bctx.fillRect(0, 0, 1, 1);                                               // 974  // 982\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;                        // 975  // 983\n                                                                                 // 976  // 984\n        /* Read back the pixels of the canvas we got to tell which part of the   // 977  // 985\n           canvas is empty.                                                      // 978  // 986\n           (no clearCanvas only works with a canvas, not divs) */                // 979  // 987\n        var imageData =                                                          // 980  // 988\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;     // 981  // 989\n                                                                                 // 982  // 990\n        gx = ngx;                                                                // 983  // 991\n        var x, y;                                                                // 984  // 992\n        while (gx--) {                                                           // 985  // 993\n          grid[gx] = [];                                                         // 986  // 994\n          gy = ngy;                                                              // 987  // 995\n          while (gy--) {                                                         // 988  // 996\n            y = g;                                                               // 989  // 997\n            singleGridLoop: while (y--) {                                        // 990  // 998\n              x = g;                                                             // 991  // 999\n              while (x--) {                                                      // 992  // 1000\n                i = 4;                                                           // 993  // 1001\n                while (i--) {                                                    // 994  // 1002\n                  if (imageData[((gy * g + y) * ngx * g +                        // 995  // 1003\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {        // 996  // 1004\n                    grid[gx][gy] = false;                                        // 997  // 1005\n                    break singleGridLoop;                                        // 998  // 1006\n                  }                                                              // 999  // 1007\n                }                                                                // 1000\n              }                                                                  // 1001\n            }                                                                    // 1002\n            if (grid[gx][gy] !== false) {                                        // 1003\n              grid[gx][gy] = true;                                               // 1004\n            }                                                                    // 1005\n          }                                                                      // 1006\n        }                                                                        // 1007\n                                                                                 // 1008\n        imageData = bctx = bgPixel = undefined;                                  // 1009\n      }                                                                          // 1010\n                                                                                 // 1011\n      // fill the infoGrid with empty state if we need it                        // 1012\n      if (settings.hover || settings.click) {                                    // 1013\n                                                                                 // 1014\n        interactive = true;                                                      // 1015\n                                                                                 // 1016\n        /* fill the grid with empty state */                                     // 1017\n        gx = ngx + 1;                                                            // 1018\n        while (gx--) {                                                           // 1019\n          infoGrid[gx] = [];                                                     // 1020\n        }                                                                        // 1021\n                                                                                 // 1022\n        if (settings.hover) {                                                    // 1023\n          canvas.addEventListener('mousemove', wordcloudhover);                  // 1024\n        }                                                                        // 1025\n                                                                                 // 1026\n        if (settings.click) {                                                    // 1027\n          canvas.addEventListener('click', wordcloudclick);                      // 1028\n        }                                                                        // 1029\n                                                                                 // 1030\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {   // 1031\n          canvas.removeEventListener('wordcloudstart', stopInteraction);         // 1032\n                                                                                 // 1033\n          canvas.removeEventListener('mousemove', wordcloudhover);               // 1034\n          canvas.removeEventListener('click', wordcloudclick);                   // 1035\n          hovered = undefined;                                                   // 1036\n        });                                                                      // 1037\n      }                                                                          // 1038\n                                                                                 // 1039\n      i = 0;                                                                     // 1040\n      var loopingFunction, stoppingFunction;                                     // 1041\n      if (settings.wait !== 0) {                                                 // 1042\n        loopingFunction = window.setTimeout;                                     // 1043\n        stoppingFunction = window.clearTimeout;                                  // 1044\n      } else {                                                                   // 1045\n        loopingFunction = window.setImmediate;                                   // 1046\n        stoppingFunction = window.clearImmediate;                                // 1047\n      }                                                                          // 1048\n                                                                                 // 1049\n      var addEventListener = function addEventListener(type, listener) {         // 1050\n        elements.forEach(function(el) {                                          // 1051\n          el.addEventListener(type, listener);                                   // 1052\n        }, this);                                                                // 1053\n      };                                                                         // 1054\n                                                                                 // 1055\n      var removeEventListener = function removeEventListener(type, listener) {   // 1056\n        elements.forEach(function(el) {                                          // 1057\n          el.removeEventListener(type, listener);                                // 1058\n        }, this);                                                                // 1059\n      };                                                                         // 1060\n                                                                                 // 1061\n      var anotherWordCloudStart = function anotherWordCloudStart() {             // 1062\n        removeEventListener('wordcloudstart', anotherWordCloudStart);            // 1063\n        stoppingFunction(timer);                                                 // 1064\n      };                                                                         // 1065\n                                                                                 // 1066\n      addEventListener('wordcloudstart', anotherWordCloudStart);                 // 1067\n                                                                                 // 1068\n      var timer = loopingFunction(function loop() {                              // 1069\n        if (i >= settings.list.length) {                                         // 1070\n          stoppingFunction(timer);                                               // 1071\n          sendEvent('wordcloudstop', false);                                     // 1072\n          removeEventListener('wordcloudstart', anotherWordCloudStart);          // 1073\n                                                                                 // 1074\n          return;                                                                // 1075\n        }                                                                        // 1076\n        escapeTime = (new Date()).getTime();                                     // 1077\n        var drawn = putWord(settings.list[i]);                                   // 1078\n        var canceled = !sendEvent('wordclouddrawn', true, {                      // 1079\n          item: settings.list[i], drawn: drawn });                               // 1080\n        if (exceedTime() || canceled) {                                          // 1081\n          stoppingFunction(timer);                                               // 1082\n          settings.abort();                                                      // 1083\n          sendEvent('wordcloudabort', false);                                    // 1084\n          sendEvent('wordcloudstop', false);                                     // 1085\n          removeEventListener('wordcloudstart', anotherWordCloudStart);          // 1086\n          return;                                                                // 1087\n        }                                                                        // 1088\n        i++;                                                                     // 1089\n        timer = loopingFunction(loop, settings.wait);                            // 1090\n      }, settings.wait);                                                         // 1091\n    };                                                                           // 1092\n                                                                                 // 1093\n    // All set, start the drawing                                                // 1094\n    start();                                                                     // 1095\n  };                                                                             // 1096\n                                                                                 // 1097\n  WordCloud.isSupported = isSupported;                                           // 1098\n  WordCloud.miniumFontSize = miniumFontSize;                                     // 1099\n                                                                                 // 1100\n  // Expose the library as an AMD module                                         // 1101\n  if (typeof global.define === 'function' && global.define.amd) {                // 1102\n    global.define('wordcloud', [], function() { return WordCloud; });            // 1103\n  } else {                                                                       // 1104\n    global.WordCloud = WordCloud;                                                // 1105\n  }                                                                              // 1106\n                                                                                 // 1107\n})(window);                                                                      // 1108\n                                                                                 // 1109\n///////////////////////////////////////////////////////////////////////////////////      // 1118\n                                                                                         // 1119\n}).call(this);                                                                           // 1120\n                                                                                         // 1121\n                                                                                         // 1122\n                                                                                         // 1123\n                                                                                         // 1124\n                                                                                         // 1125\n                                                                                         // 1126\n(function () {                                                                           // 1127\n                                                                                         // 1128\n///////////////////////////////////////////////////////////////////////////////////      // 1129\n//                                                                               //      // 1130\n// packages/overture8:wordcloud2/overture8:wordcloud2.js                         //      // 1131\n//                                                                               //      // 1132\n///////////////////////////////////////////////////////////////////////////////////      // 1133\n                                                                                 //      // 1134\n// Write your package code here!                                                 // 1    // 1135\n                                                                                 // 2    // 1136\n///////////////////////////////////////////////////////////////////////////////////      // 1137\n                                                                                         // 1138\n}).call(this);                                                                           // 1139\n                                                                                         // 1140\n///////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['overture8:wordcloud2'] = {};\n\n})();\n","servePath":"/packages/overture8_wordcloud2.js","sourceMap":{"version":3,"sources":["/packages/overture8_wordcloud2/packages/overture8_wordcloud2.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG","file":"/packages/overture8_wordcloud2.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/overture8:wordcloud2/wordcloud2.js                                   //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n/*!                                                                              // 1\n * wordcloud2.js                                                                 // 2\n * http://timdream.org/wordcloud2.js/                                            // 3\n *                                                                               // 4\n * Copyright 2011 - 2013 Tim Chien                                               // 5\n * Released under the MIT license                                                // 6\n */                                                                              // 7\n                                                                                 // 8\n'use strict';                                                                    // 9\n                                                                                 // 10\n// setImmediate                                                                  // 11\nif (!window.setImmediate) {                                                      // 12\n  window.setImmediate = (function setupSetImmediate() {                          // 13\n    return window.msSetImmediate ||                                              // 14\n    window.webkitSetImmediate ||                                                 // 15\n    window.mozSetImmediate ||                                                    // 16\n    window.oSetImmediate ||                                                      // 17\n    (function setupSetZeroTimeout() {                                            // 18\n      if (!window.postMessage || !window.addEventListener) {                     // 19\n        return null;                                                             // 20\n      }                                                                          // 21\n                                                                                 // 22\n      var callbacks = [undefined];                                               // 23\n      var message = 'zero-timeout-message';                                      // 24\n                                                                                 // 25\n      // Like setTimeout, but only takes a function argument.  There's           // 26\n      // no time argument (always zero) and no arguments (you have to            // 27\n      // use a closure).                                                         // 28\n      var setZeroTimeout = function setZeroTimeout(callback) {                   // 29\n        var id = callbacks.length;                                               // 30\n        callbacks.push(callback);                                                // 31\n        window.postMessage(message + id.toString(36), '*');                      // 32\n                                                                                 // 33\n        return id;                                                               // 34\n      };                                                                         // 35\n                                                                                 // 36\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {   // 37\n        // Skipping checking event source, retarded IE confused this window      // 38\n        // object with another in the presence of iframe                         // 39\n        if (typeof evt.data !== 'string' ||                                      // 40\n            evt.data.substr(0, message.length) !== message/* ||                  // 41\n            evt.source !== window */) {                                          // 42\n          return;                                                                // 43\n        }                                                                        // 44\n                                                                                 // 45\n        evt.stopImmediatePropagation();                                          // 46\n                                                                                 // 47\n        var id = parseInt(evt.data.substr(message.length), 36);                  // 48\n        if (!callbacks[id]) {                                                    // 49\n          return;                                                                // 50\n        }                                                                        // 51\n                                                                                 // 52\n        callbacks[id]();                                                         // 53\n        callbacks[id] = undefined;                                               // 54\n      }, true);                                                                  // 55\n                                                                                 // 56\n      /* specify clearImmediate() here since we need the scope */                // 57\n      window.clearImmediate = function clearZeroTimeout(id) {                    // 58\n        if (!callbacks[id]) {                                                    // 59\n          return;                                                                // 60\n        }                                                                        // 61\n                                                                                 // 62\n        callbacks[id] = undefined;                                               // 63\n      };                                                                         // 64\n                                                                                 // 65\n      return setZeroTimeout;                                                     // 66\n    })() ||                                                                      // 67\n    // fallback                                                                  // 68\n    function setImmediateFallback(fn) {                                          // 69\n      window.setTimeout(fn, 0);                                                  // 70\n    };                                                                           // 71\n  })();                                                                          // 72\n}                                                                                // 73\n                                                                                 // 74\nif (!window.clearImmediate) {                                                    // 75\n  window.clearImmediate = (function setupClearImmediate() {                      // 76\n    return window.msClearImmediate ||                                            // 77\n    window.webkitClearImmediate ||                                               // 78\n    window.mozClearImmediate ||                                                  // 79\n    window.oClearImmediate ||                                                    // 80\n    // \"clearZeroTimeout\" is implement on the previous block ||                  // 81\n    // fallback                                                                  // 82\n    function clearImmediateFallback(timer) {                                     // 83\n      window.clearTimeout(timer);                                                // 84\n    };                                                                           // 85\n  })();                                                                          // 86\n}                                                                                // 87\n                                                                                 // 88\n(function(global) {                                                              // 89\n                                                                                 // 90\n  // Check if WordCloud can run on this browser                                  // 91\n  var isSupported = (function isSupported() {                                    // 92\n    var canvas = document.createElement('canvas');                               // 93\n    if (!canvas || !canvas.getContext) {                                         // 94\n      return false;                                                              // 95\n    }                                                                            // 96\n                                                                                 // 97\n    var ctx = canvas.getContext('2d');                                           // 98\n    if (!ctx.getImageData) {                                                     // 99\n      return false;                                                              // 100\n    }                                                                            // 101\n    if (!ctx.fillText) {                                                         // 102\n      return false;                                                              // 103\n    }                                                                            // 104\n                                                                                 // 105\n    if (!Array.prototype.some) {                                                 // 106\n      return false;                                                              // 107\n    }                                                                            // 108\n    if (!Array.prototype.push) {                                                 // 109\n      return false;                                                              // 110\n    }                                                                            // 111\n                                                                                 // 112\n    return true;                                                                 // 113\n  }());                                                                          // 114\n                                                                                 // 115\n  // Find out if the browser impose minium font size by                          // 116\n  // drawing small texts on a canvas and measure it's width.                     // 117\n  var miniumFontSize = (function getMiniumFontSize() {                           // 118\n    if (!isSupported) {                                                          // 119\n      return;                                                                    // 120\n    }                                                                            // 121\n                                                                                 // 122\n    var ctx = document.createElement('canvas').getContext('2d');                 // 123\n                                                                                 // 124\n    // start from 20                                                             // 125\n    var size = 20;                                                               // 126\n                                                                                 // 127\n    // two sizes to measure                                                      // 128\n    var hanWidth, mWidth;                                                        // 129\n                                                                                 // 130\n    while (size) {                                                               // 131\n      ctx.font = size.toString(10) + 'px sans-serif';                            // 132\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&                      // 133\n          (ctx.measureText('m').width) === mWidth) {                             // 134\n        return (size + 1);                                                       // 135\n      }                                                                          // 136\n                                                                                 // 137\n      hanWidth = ctx.measureText('\\uFF37').width;                                // 138\n      mWidth = ctx.measureText('m').width;                                       // 139\n                                                                                 // 140\n      size--;                                                                    // 141\n    }                                                                            // 142\n                                                                                 // 143\n    return 0;                                                                    // 144\n  })();                                                                          // 145\n                                                                                 // 146\n  // Based on http://jsfromhell.com/array/shuffle                                // 147\n  var shuffleArray = function shuffleArray(arr) {                                // 148\n    for (var j, x, i = arr.length; i;                                            // 149\n      j = Math.floor(Math.random() * i),                                         // 150\n      x = arr[--i], arr[i] = arr[j],                                             // 151\n      arr[j] = x) {}                                                             // 152\n    return arr;                                                                  // 153\n  };                                                                             // 154\n                                                                                 // 155\n  var WordCloud = function WordCloud(elements, options) {                        // 156\n    if (!isSupported) {                                                          // 157\n      return;                                                                    // 158\n    }                                                                            // 159\n                                                                                 // 160\n    if (!Array.isArray(elements)) {                                              // 161\n      elements = [elements];                                                     // 162\n    }                                                                            // 163\n                                                                                 // 164\n    elements.forEach(function(el, i) {                                           // 165\n      if (typeof el === 'string') {                                              // 166\n        elements[i] = document.getElementById(el);                               // 167\n        if (!elements[i]) {                                                      // 168\n          throw 'The element id specified is not found.';                        // 169\n        }                                                                        // 170\n      } else if (!el.tagName && !el.appendChild) {                               // 171\n        throw 'You must pass valid HTML elements, or ID of the element.';        // 172\n      }                                                                          // 173\n    });                                                                          // 174\n                                                                                 // 175\n    /* Default values to be overwritten by options object */                     // 176\n    var settings = {                                                             // 177\n      list: [],                                                                  // 178\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +                      // 179\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',       // 180\n      fontWeight: 'normal',                                                      // 181\n      color: 'random-dark',                                                      // 182\n      minSize: 0, // 0 to disable                                                // 183\n      weightFactor: 1,                                                           // 184\n      clearCanvas: true,                                                         // 185\n      backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)         // 186\n                                                                                 // 187\n      gridSize: 8,                                                               // 188\n      origin: null,                                                              // 189\n                                                                                 // 190\n      drawMask: false,                                                           // 191\n      maskColor: 'rgba(255,0,0,0.3)',                                            // 192\n      maskGapWidth: 0.3,                                                         // 193\n                                                                                 // 194\n      wait: 0,                                                                   // 195\n      abortThreshold: 0, // disabled                                             // 196\n      abort: function noop() {},                                                 // 197\n                                                                                 // 198\n      minRotation: - Math.PI / 2,                                                // 199\n      maxRotation: Math.PI / 2,                                                  // 200\n                                                                                 // 201\n      shuffle: true,                                                             // 202\n      rotateRatio: 0.1,                                                          // 203\n                                                                                 // 204\n      shape: 'circle',                                                           // 205\n      ellipticity: 0.65,                                                         // 206\n                                                                                 // 207\n      hover: null,                                                               // 208\n      click: null                                                                // 209\n    };                                                                           // 210\n                                                                                 // 211\n    if (options) {                                                               // 212\n      for (var key in options) {                                                 // 213\n        if (key in settings) {                                                   // 214\n          settings[key] = options[key];                                          // 215\n        }                                                                        // 216\n      }                                                                          // 217\n    }                                                                            // 218\n                                                                                 // 219\n    /* Convert weightFactor into a function */                                   // 220\n    if (typeof settings.weightFactor !== 'function') {                           // 221\n      var factor = settings.weightFactor;                                        // 222\n      settings.weightFactor = function weightFactor(pt) {                        // 223\n        return pt * factor; //in px                                              // 224\n      };                                                                         // 225\n    }                                                                            // 226\n                                                                                 // 227\n    /* Convert shape into a function */                                          // 228\n    if (typeof settings.shape !== 'function') {                                  // 229\n      switch (settings.shape) {                                                  // 230\n        case 'circle':                                                           // 231\n        /* falls through */                                                      // 232\n        default:                                                                 // 233\n          // 'circle' is the default and a shortcut in the code loop.            // 234\n          settings.shape = 'circle';                                             // 235\n          break;                                                                 // 236\n                                                                                 // 237\n        case 'cardioid':                                                         // 238\n          settings.shape = function shapeCardioid(theta) {                       // 239\n            return 1 - Math.sin(theta);                                          // 240\n          };                                                                     // 241\n          break;                                                                 // 242\n                                                                                 // 243\n        /*                                                                       // 244\n                                                                                 // 245\n        To work out an X-gon, one has to calculate \"m\",                          // 246\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))                // 247\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28 // 248\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29                   // 249\n                                                                                 // 250\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))        // 251\n        where t' equals to mod(t, 2PI/X);                                        // 252\n                                                                                 // 253\n        */                                                                       // 254\n                                                                                 // 255\n        case 'diamond':                                                          // 256\n        case 'square':                                                           // 257\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+   // 258\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D   // 259\n          // +0+..+2*PI                                                          // 260\n          settings.shape = function shapeSquare(theta) {                         // 261\n            var thetaPrime = theta % (2 * Math.PI / 4);                          // 262\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));            // 263\n          };                                                                     // 264\n          break;                                                                 // 265\n                                                                                 // 266\n        case 'triangle-forward':                                                 // 267\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+   // 268\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29   // 269\n          // %29%29%2C+t+%3D+0+..+2*PI                                           // 270\n          settings.shape = function shapeTriangle(theta) {                       // 271\n            var thetaPrime = theta % (2 * Math.PI / 3);                          // 272\n            return 1 / (Math.cos(thetaPrime) +                                   // 273\n                        Math.sqrt(3) * Math.sin(thetaPrime));                    // 274\n          };                                                                     // 275\n          break;                                                                 // 276\n                                                                                 // 277\n        case 'triangle':                                                         // 278\n        case 'triangle-upright':                                                 // 279\n          settings.shape = function shapeTriangle(theta) {                       // 280\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);      // 281\n            return 1 / (Math.cos(thetaPrime) +                                   // 282\n                        Math.sqrt(3) * Math.sin(thetaPrime));                    // 283\n          };                                                                     // 284\n          break;                                                                 // 285\n                                                                                 // 286\n        case 'pentagon':                                                         // 287\n          settings.shape = function shapePentagon(theta) {                       // 288\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);                // 289\n            return 1 / (Math.cos(thetaPrime) +                                   // 290\n                        0.726543 * Math.sin(thetaPrime));                        // 291\n          };                                                                     // 292\n          break;                                                                 // 293\n                                                                                 // 294\n        case 'star':                                                             // 295\n          settings.shape = function shapeStar(theta) {                           // 296\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);               // 297\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) { // 298\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +            // 299\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));  // 300\n            } else {                                                             // 301\n              return 1 / (Math.cos(thetaPrime) +                                 // 302\n                          3.07768 * Math.sin(thetaPrime));                       // 303\n            }                                                                    // 304\n          };                                                                     // 305\n          break;                                                                 // 306\n      }                                                                          // 307\n    }                                                                            // 308\n                                                                                 // 309\n    /* Make sure gridSize is a whole number and is not smaller than 4px */       // 310\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);              // 311\n                                                                                 // 312\n    /* shorthand */                                                              // 313\n    var g = settings.gridSize;                                                   // 314\n    var maskRectWidth = g - settings.maskGapWidth;                               // 315\n                                                                                 // 316\n    /* normalize rotation settings */                                            // 317\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);   // 318\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);      // 319\n                                                                                 // 320\n    /* information/object available to all functions, set when start() */        // 321\n    var grid, // 2d array containing filling information                         // 322\n      ngx, ngy, // width and height of the grid                                  // 323\n      center, // position of the center of the cloud                             // 324\n      maxRadius;                                                                 // 325\n                                                                                 // 326\n    /* timestamp for measuring each putWord() action */                          // 327\n    var escapeTime;                                                              // 328\n                                                                                 // 329\n    /* function for getting the color of the text */                             // 330\n    var getTextColor;                                                            // 331\n    switch (settings.color) {                                                    // 332\n      case 'random-dark':                                                        // 333\n        getTextColor = function getRandomDarkColor() {                           // 334\n          return 'rgb(' +                                                        // 335\n            Math.floor(Math.random() * 128).toString(10) + ',' +                 // 336\n            Math.floor(Math.random() * 128).toString(10) + ',' +                 // 337\n            Math.floor(Math.random() * 128).toString(10) + ')';                  // 338\n        };                                                                       // 339\n        break;                                                                   // 340\n                                                                                 // 341\n      case 'random-light':                                                       // 342\n        getTextColor = function getRandomLightColor() {                          // 343\n          return 'rgb(' +                                                        // 344\n            Math.floor(Math.random() * 128 + 128).toString(10) + ',' +           // 345\n            Math.floor(Math.random() * 128 + 128).toString(10) + ',' +           // 346\n            Math.floor(Math.random() * 128 + 128).toString(10) + ')';            // 347\n        };                                                                       // 348\n        break;                                                                   // 349\n                                                                                 // 350\n      default:                                                                   // 351\n        if (typeof settings.color === 'function') {                              // 352\n          getTextColor = settings.color;                                         // 353\n        }                                                                        // 354\n        break;                                                                   // 355\n    }                                                                            // 356\n                                                                                 // 357\n    /* Interactive */                                                            // 358\n    var interactive = false;                                                     // 359\n    var infoGrid = [];                                                           // 360\n    var hovered;                                                                 // 361\n                                                                                 // 362\n    var getInfoGridFromMouseEvent = function getInfoGridFromMouseEvent(evt) {    // 363\n      var canvas = evt.currentTarget;                                            // 364\n      var rect = canvas.getBoundingClientRect();                                 // 365\n      var eventX = evt.clientX - rect.left;                                      // 366\n      var eventY = evt.clientY - rect.top;                                       // 367\n                                                                                 // 368\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);       // 369\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);     // 370\n                                                                                 // 371\n      return infoGrid[x][y];                                                     // 372\n    };                                                                           // 373\n                                                                                 // 374\n    var wordcloudhover = function wordcloudhover(evt) {                          // 375\n      var info = getInfoGridFromMouseEvent(evt);                                 // 376\n                                                                                 // 377\n      if (hovered === info) {                                                    // 378\n        return;                                                                  // 379\n      }                                                                          // 380\n                                                                                 // 381\n      hovered = info;                                                            // 382\n      if (!info) {                                                               // 383\n        settings.hover(undefined, undefined, evt);                               // 384\n                                                                                 // 385\n        return;                                                                  // 386\n      }                                                                          // 387\n                                                                                 // 388\n      settings.hover(info.item, info.dimension, evt);                            // 389\n                                                                                 // 390\n    };                                                                           // 391\n                                                                                 // 392\n    var wordcloudclick = function wordcloudclick(evt) {                          // 393\n      var info = getInfoGridFromMouseEvent(evt);                                 // 394\n      if (!info) {                                                               // 395\n        return;                                                                  // 396\n      }                                                                          // 397\n                                                                                 // 398\n      settings.click(info.item, info.dimension, evt);                            // 399\n    };                                                                           // 400\n                                                                                 // 401\n    /* Get points on the grid for a given radius away from the center */         // 402\n    var pointsAtRadius = [];                                                     // 403\n    var getPointsAtRadius = function getPointsAtRadius(radius) {                 // 404\n      if (pointsAtRadius[radius]) {                                              // 405\n        return pointsAtRadius[radius];                                           // 406\n      }                                                                          // 407\n                                                                                 // 408\n      // Look for these number of points on each radius                          // 409\n      var T = radius * 8;                                                        // 410\n                                                                                 // 411\n      // Getting all the points at this radius                                   // 412\n      var t = T;                                                                 // 413\n      var points = [];                                                           // 414\n                                                                                 // 415\n      if (radius === 0) {                                                        // 416\n        points.push([center[0], center[1], 0]);                                  // 417\n      }                                                                          // 418\n                                                                                 // 419\n      while (t--) {                                                              // 420\n        // distort the radius to put the cloud in shape                          // 421\n        var rx = 1;                                                              // 422\n        if (settings.shape !== 'circle') {                                       // 423\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1                    // 424\n        }                                                                        // 425\n                                                                                 // 426\n        // Push [x, y, t]; t is used solely for getTextColor()                   // 427\n        points.push([                                                            // 428\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),              // 429\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *             // 430\n            settings.ellipticity,                                                // 431\n          t / T * 2 * Math.PI]);                                                 // 432\n      }                                                                          // 433\n                                                                                 // 434\n      pointsAtRadius[radius] = points;                                           // 435\n      return points;                                                             // 436\n    };                                                                           // 437\n                                                                                 // 438\n    /* Return true if we had spent too much time */                              // 439\n    var exceedTime = function exceedTime() {                                     // 440\n      return ((settings.abortThreshold > 0) &&                                   // 441\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold));        // 442\n    };                                                                           // 443\n                                                                                 // 444\n    /* Get the deg of rotation according to settings, and luck. */               // 445\n    var getRotateDeg = function getRotateDeg() {                                 // 446\n      if (settings.rotateRatio === 0) {                                          // 447\n        return 0;                                                                // 448\n      }                                                                          // 449\n                                                                                 // 450\n      if (Math.random() > settings.rotateRatio) {                                // 451\n        return 0;                                                                // 452\n      }                                                                          // 453\n                                                                                 // 454\n      if (rotationRange === 0) {                                                 // 455\n        return minRotation;                                                      // 456\n      }                                                                          // 457\n                                                                                 // 458\n      return minRotation + Math.random() * rotationRange;                        // 459\n    };                                                                           // 460\n                                                                                 // 461\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {            // 462\n      // calculate the acutal font size                                          // 463\n      // fontSize === 0 means weightFactor function wants the text skipped,      // 464\n      // and size < minSize means we cannot draw the text.                       // 465\n      var debug = false;                                                         // 466\n      var fontSize = settings.weightFactor(weight);                              // 467\n      if (fontSize <= settings.minSize) {                                        // 468\n        return false;                                                            // 469\n      }                                                                          // 470\n                                                                                 // 471\n      // Scale factor here is to make sure fillText is not limited by            // 472\n      // the minium font size set by browser.                                    // 473\n      // It will always be 1 or 2n.                                              // 474\n      var mu = 1;                                                                // 475\n      if (fontSize < miniumFontSize) {                                           // 476\n        mu = (function calculateScaleFactor() {                                  // 477\n          var mu = 2;                                                            // 478\n          while (mu * fontSize < miniumFontSize) {                               // 479\n            mu += 2;                                                             // 480\n          }                                                                      // 481\n          return mu;                                                             // 482\n        })();                                                                    // 483\n      }                                                                          // 484\n                                                                                 // 485\n      var fcanvas = document.createElement('canvas');                            // 486\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });         // 487\n                                                                                 // 488\n      fctx.font = settings.fontWeight + ' ' +                                    // 489\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;              // 490\n                                                                                 // 491\n      // Estimate the dimension of the text with measureText().                  // 492\n      var fw = fctx.measureText(word).width / mu;                                // 493\n      var fh = Math.max(fontSize * mu,                                           // 494\n                        fctx.measureText('m').width,                             // 495\n                        fctx.measureText('\\uFF37').width) / mu;                  // 496\n                                                                                 // 497\n      // Create a boundary box that is larger than our estimates,                // 498\n      // so text don't get cut of (it sill might)                                // 499\n      var boxWidth = fw + fh * 2;                                                // 500\n      var boxHeight = fh * 3;                                                    // 501\n      var fgw = Math.ceil(boxWidth / g);                                         // 502\n      var fgh = Math.ceil(boxHeight / g);                                        // 503\n      boxWidth = fgw * g;                                                        // 504\n      boxHeight = fgh * g;                                                       // 505\n                                                                                 // 506\n      // Calculate the proper offsets to make the text centered at               // 507\n      // the preferred position.                                                 // 508\n                                                                                 // 509\n      // This is simply half of the width.                                       // 510\n      var fillTextOffsetX = - fw / 2;                                            // 511\n      // Instead of moving the box to the exact middle of the preferred          // 512\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look     // 513\n      // vertical centered.                                                      // 514\n      var fillTextOffsetY = - fh * 0.4;                                          // 515\n                                                                                 // 516\n      // Calculate the actual dimension of the canvas, considering the rotation. // 517\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +            // 518\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);      // 519\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +            // 520\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);      // 521\n      var width = cgw * g;                                                       // 522\n      var height = cgh * g;                                                      // 523\n                                                                                 // 524\n      fcanvas.setAttribute('width', width);                                      // 525\n      fcanvas.setAttribute('height', height);                                    // 526\n                                                                                 // 527\n      if (debug) {                                                               // 528\n        // Attach fcanvas to the DOM                                             // 529\n        document.body.appendChild(fcanvas);                                      // 530\n        // Save it's state so that we could restore and draw the grid correctly. // 531\n        fctx.save();                                                             // 532\n      }                                                                          // 533\n                                                                                 // 534\n      // Scale the canvas with |mu|.                                             // 535\n      fctx.scale(1 / mu, 1 / mu);                                                // 536\n      fctx.translate(width * mu / 2, height * mu / 2);                           // 537\n      fctx.rotate(- rotateDeg);                                                  // 538\n                                                                                 // 539\n      // Once the width/height is set, ctx info will be reset.                   // 540\n      // Set it again here.                                                      // 541\n      fctx.font = settings.fontWeight + ' ' +                                    // 542\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;              // 543\n                                                                                 // 544\n      // Fill the text into the fcanvas.                                         // 545\n      // XXX: We cannot because textBaseline = 'top' here because                // 546\n      // Firefox and Chrome uses different default line-height for canvas.       // 547\n      // Please read https://bugzil.la/737852#c6.                                // 548\n      // Here, we use textBaseline = 'middle' and draw the text at exactly       // 549\n      // 0.5 * fontSize lower.                                                   // 550\n      fctx.fillStyle = '#000';                                                   // 551\n      fctx.textBaseline = 'middle';                                              // 552\n      fctx.fillText(word, fillTextOffsetX * mu,                                  // 553\n                    (fillTextOffsetY + fontSize * 0.5) * mu);                    // 554\n                                                                                 // 555\n      // Get the pixels of the text                                              // 556\n      var imageData = fctx.getImageData(0, 0, width, height).data;               // 557\n                                                                                 // 558\n      if (exceedTime()) {                                                        // 559\n        return false;                                                            // 560\n      }                                                                          // 561\n                                                                                 // 562\n      if (debug) {                                                               // 563\n        // Draw the box of the original estimation                               // 564\n        fctx.strokeRect(fillTextOffsetX * mu,                                    // 565\n                        fillTextOffsetY, fw * mu, fh * mu);                      // 566\n        fctx.restore();                                                          // 567\n      }                                                                          // 568\n                                                                                 // 569\n      // Read the pixels and save the information to the occupied array          // 570\n      var occupied = [];                                                         // 571\n      var gx = cgw, gy, x, y;                                                    // 572\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];                         // 573\n      while (gx--) {                                                             // 574\n        gy = cgh;                                                                // 575\n        while (gy--) {                                                           // 576\n          y = g;                                                                 // 577\n          singleGridLoop: {                                                      // 578\n            while (y--) {                                                        // 579\n              x = g;                                                             // 580\n              while (x--) {                                                      // 581\n                if (imageData[((gy * g + y) * width +                            // 582\n                               (gx * g + x)) * 4 + 3]) {                         // 583\n                  occupied.push([gx, gy]);                                       // 584\n                                                                                 // 585\n                  if (gx < bounds[3]) {                                          // 586\n                    bounds[3] = gx;                                              // 587\n                  }                                                              // 588\n                  if (gx > bounds[1]) {                                          // 589\n                    bounds[1] = gx;                                              // 590\n                  }                                                              // 591\n                  if (gy < bounds[0]) {                                          // 592\n                    bounds[0] = gy;                                              // 593\n                  }                                                              // 594\n                  if (gy > bounds[2]) {                                          // 595\n                    bounds[2] = gy;                                              // 596\n                  }                                                              // 597\n                                                                                 // 598\n                  if (debug) {                                                   // 599\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';                     // 600\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);             // 601\n                  }                                                              // 602\n                  break singleGridLoop;                                          // 603\n                }                                                                // 604\n              }                                                                  // 605\n            }                                                                    // 606\n            if (debug) {                                                         // 607\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';                           // 608\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);                   // 609\n            }                                                                    // 610\n          }                                                                      // 611\n        }                                                                        // 612\n      }                                                                          // 613\n                                                                                 // 614\n      if (debug) {                                                               // 615\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';                                 // 616\n        fctx.fillRect(bounds[3] * g,                                             // 617\n                      bounds[0] * g,                                             // 618\n                      (bounds[1] - bounds[3] + 1) * g,                           // 619\n                      (bounds[2] - bounds[0] + 1) * g);                          // 620\n      }                                                                          // 621\n                                                                                 // 622\n      // Return information needed to create the text on the real canvas         // 623\n      return {                                                                   // 624\n        mu: mu,                                                                  // 625\n        occupied: occupied,                                                      // 626\n        bounds: bounds,                                                          // 627\n        gw: cgw,                                                                 // 628\n        gh: cgh,                                                                 // 629\n        fillTextOffsetX: fillTextOffsetX,                                        // 630\n        fillTextOffsetY: fillTextOffsetY,                                        // 631\n        fillTextWidth: fw,                                                       // 632\n        fillTextHeight: fh,                                                      // 633\n        fontSize: fontSize                                                       // 634\n      };                                                                         // 635\n    };                                                                           // 636\n                                                                                 // 637\n    /* Determine if there is room available in the given dimension */            // 638\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {             // 639\n      // Go through the occupied points,                                         // 640\n      // return false if the space is not available.                             // 641\n      var i = occupied.length;                                                   // 642\n      while (i--) {                                                              // 643\n        var px = gx + occupied[i][0];                                            // 644\n        var py = gy + occupied[i][1];                                            // 645\n                                                                                 // 646\n        if (px >= ngx || py >= ngy || px < 0 || py < 0 || !grid[px][py]) {       // 647\n          return false;                                                          // 648\n        }                                                                        // 649\n      }                                                                          // 650\n      return true;                                                               // 651\n    };                                                                           // 652\n                                                                                 // 653\n    /* Actually draw the text on the grid */                                     // 654\n    var drawText = function drawText(gx, gy, info, word, weight,                 // 655\n                                     distance, theta, rotateDeg, attributes) {   // 656\n                                                                                 // 657\n      var fontSize = info.fontSize;                                              // 658\n      var color;                                                                 // 659\n      if (getTextColor) {                                                        // 660\n        color = getTextColor(word, weight, fontSize, distance, theta);           // 661\n      } else {                                                                   // 662\n        color = settings.color;                                                  // 663\n      }                                                                          // 664\n                                                                                 // 665\n      var dimension;                                                             // 666\n      var bounds = info.bounds;                                                  // 667\n      dimension = {                                                              // 668\n        x: (gx + bounds[3]) * g,                                                 // 669\n        y: (gy + bounds[0]) * g,                                                 // 670\n        w: (bounds[1] - bounds[3] + 1) * g,                                      // 671\n        h: (bounds[2] - bounds[0] + 1) * g                                       // 672\n      };                                                                         // 673\n                                                                                 // 674\n      elements.forEach(function(el) {                                            // 675\n        if (el.getContext) {                                                     // 676\n          var ctx = el.getContext('2d');                                         // 677\n          var mu = info.mu;                                                      // 678\n                                                                                 // 679\n          // Save the current state before messing it                            // 680\n          ctx.save();                                                            // 681\n          ctx.scale(1 / mu, 1 / mu);                                             // 682\n                                                                                 // 683\n          ctx.font = settings.fontWeight + ' ' +                                 // 684\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // 685\n          ctx.fillStyle = color;                                                 // 686\n                                                                                 // 687\n          // Translate the canvas position to the origin coordinate of where     // 688\n          // the text should be put.                                             // 689\n          ctx.translate((gx + info.gw / 2) * g * mu,                             // 690\n                        (gy + info.gh / 2) * g * mu);                            // 691\n                                                                                 // 692\n          if (rotateDeg !== 0) {                                                 // 693\n            ctx.rotate(- rotateDeg);                                             // 694\n          }                                                                      // 695\n                                                                                 // 696\n          // Finally, fill the text.                                             // 697\n                                                                                 // 698\n          // XXX: We cannot because textBaseline = 'top' here because            // 699\n          // Firefox and Chrome uses different default line-height for canvas.   // 700\n          // Please read https://bugzil.la/737852#c6.                            // 701\n          // Here, we use textBaseline = 'middle' and draw the text at exactly   // 702\n          // 0.5 * fontSize lower.                                               // 703\n          ctx.textBaseline = 'middle';                                           // 704\n          ctx.fillText(word, info.fillTextOffsetX * mu,                          // 705\n                             (info.fillTextOffsetY + fontSize * 0.5) * mu);      // 706\n                                                                                 // 707\n          // The below box is always matches how <span>s are positioned          // 708\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,          // 709\n            info.fillTextWidth, info.fillTextHeight); */                         // 710\n                                                                                 // 711\n          // Restore the state.                                                  // 712\n          ctx.restore();                                                         // 713\n        } else {                                                                 // 714\n          // drawText on DIV element                                             // 715\n          var span = document.createElement('span');                             // 716\n          var transformRule = '';                                                // 717\n          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';   // 718\n          if (info.mu !== 1) {                                                   // 719\n            transformRule +=                                                     // 720\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +               // 721\n              'scale(' + (1 / info.mu) + ')';                                    // 722\n          }                                                                      // 723\n          var styleRules = {                                                     // 724\n            'position': 'absolute',                                              // 725\n            'display': 'block',                                                  // 726\n            'font': settings.fontWeight + ' ' +                                  // 727\n                    (fontSize * info.mu) + 'px ' + settings.fontFamily,          // 728\n            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',      // 729\n            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',       // 730\n            'width': info.fillTextWidth + 'px',                                  // 731\n            'height': info.fillTextHeight + 'px',                                // 732\n            'color': color,                                                      // 733\n            'lineHeight': fontSize + 'px',                                       // 734\n            'whiteSpace': 'nowrap',                                              // 735\n            'transform': transformRule,                                          // 736\n            'webkitTransform': transformRule,                                    // 737\n            'msTransform': transformRule,                                        // 738\n            'transformOrigin': '50% 40%',                                        // 739\n            'webkitTransformOrigin': '50% 40%',                                  // 740\n            'msTransformOrigin': '50% 40%'                                       // 741\n          };                                                                     // 742\n          span.textContent = word;                                               // 743\n          for (var cssProp in styleRules) {                                      // 744\n            span.style[cssProp] = styleRules[cssProp];                           // 745\n          }                                                                      // 746\n          if (attributes) {                                                      // 747\n            for (var attribute in attributes) {                                  // 748\n              span.setAttribute(attribute, attributes[attribute]);               // 749\n            }                                                                    // 750\n          }                                                                      // 751\n          el.appendChild(span);                                                  // 752\n        }                                                                        // 753\n      });                                                                        // 754\n    };                                                                           // 755\n                                                                                 // 756\n    /* Help function to updateGrid */                                            // 757\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {      // 758\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {                              // 759\n        return;                                                                  // 760\n      }                                                                          // 761\n                                                                                 // 762\n      grid[x][y] = false;                                                        // 763\n                                                                                 // 764\n      if (drawMask) {                                                            // 765\n        var ctx = elements[0].getContext('2d');                                  // 766\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);                // 767\n      }                                                                          // 768\n                                                                                 // 769\n      if (interactive) {                                                         // 770\n        infoGrid[x][y] = { item: item, dimension: dimension };                   // 771\n      }                                                                          // 772\n    };                                                                           // 773\n                                                                                 // 774\n    /* Update the filling information of the given space with occupied points.   // 775\n       Draw the mask on the canvas if necessary. */                              // 776\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {           // 777\n      var occupied = info.occupied;                                              // 778\n      var drawMask = settings.drawMask;                                          // 779\n      var ctx;                                                                   // 780\n      if (drawMask) {                                                            // 781\n        ctx = elements[0].getContext('2d');                                      // 782\n        ctx.save();                                                              // 783\n        ctx.fillStyle = settings.maskColor;                                      // 784\n      }                                                                          // 785\n                                                                                 // 786\n      var dimension;                                                             // 787\n      if (interactive) {                                                         // 788\n        var bounds = info.bounds;                                                // 789\n        dimension = {                                                            // 790\n          x: (gx + bounds[3]) * g,                                               // 791\n          y: (gy + bounds[0]) * g,                                               // 792\n          w: (bounds[1] - bounds[3] + 1) * g,                                    // 793\n          h: (bounds[2] - bounds[0] + 1) * g                                     // 794\n        };                                                                       // 795\n      }                                                                          // 796\n                                                                                 // 797\n      var i = occupied.length;                                                   // 798\n      while (i--) {                                                              // 799\n        fillGridAt(gx + occupied[i][0], gy + occupied[i][1],                     // 800\n                   drawMask, dimension, item);                                   // 801\n      }                                                                          // 802\n                                                                                 // 803\n      if (drawMask) {                                                            // 804\n        ctx.restore();                                                           // 805\n      }                                                                          // 806\n    };                                                                           // 807\n                                                                                 // 808\n    /* putWord() processes each item on the list,                                // 809\n       calculate it's size and determine it's position, and actually             // 810\n       put it on the canvas. */                                                  // 811\n    var putWord = function putWord(item) {                                       // 812\n      var word, weight, attributes;                                              // 813\n      if (Array.isArray(item)) {                                                 // 814\n        word = item[0];                                                          // 815\n        weight = item[1];                                                        // 816\n      } else {                                                                   // 817\n        word = item.word;                                                        // 818\n        weight = item.weight;                                                    // 819\n        attributes = item.attributes;                                            // 820\n      }                                                                          // 821\n      var rotateDeg = getRotateDeg();                                            // 822\n                                                                                 // 823\n      // get info needed to put the text onto the canvas                         // 824\n      var info = getTextInfo(word, weight, rotateDeg);                           // 825\n                                                                                 // 826\n      // not getting the info means we shouldn't be drawing this one.            // 827\n      if (!info) {                                                               // 828\n        return false;                                                            // 829\n      }                                                                          // 830\n                                                                                 // 831\n      if (exceedTime()) {                                                        // 832\n        return false;                                                            // 833\n      }                                                                          // 834\n                                                                                 // 835\n      // Skip the loop if we have already know the bounding box of               // 836\n      // word is larger than the canvas.                                         // 837\n      var bounds = info.bounds;                                                  // 838\n      if ((bounds[1] - bounds[3] + 1) > ngx ||                                   // 839\n        (bounds[2] - bounds[0] + 1) > ngy) {                                     // 840\n        return false;                                                            // 841\n      }                                                                          // 842\n                                                                                 // 843\n      // Determine the position to put the text by                               // 844\n      // start looking for the nearest points                                    // 845\n      var r = maxRadius + 1;                                                     // 846\n                                                                                 // 847\n      var tryToPutWordAtPoint = function(gxy) {                                  // 848\n        var gx = Math.floor(gxy[0] - info.gw / 2);                               // 849\n        var gy = Math.floor(gxy[1] - info.gh / 2);                               // 850\n        var gw = info.gw;                                                        // 851\n        var gh = info.gh;                                                        // 852\n                                                                                 // 853\n        // If we cannot fit the text at this position, return false              // 854\n        // and go to the next position.                                          // 855\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {                        // 856\n          return false;                                                          // 857\n        }                                                                        // 858\n                                                                                 // 859\n        // Actually put the text on the canvas                                   // 860\n        drawText(gx, gy, info, word, weight,                                     // 861\n                 (maxRadius - r), gxy[2], rotateDeg, attributes);                // 862\n                                                                                 // 863\n        // Mark the spaces on the grid as filled                                 // 864\n        updateGrid(gx, gy, gw, gh, info, item);                                  // 865\n                                                                                 // 866\n        // Return true so some() will stop and also return true.                 // 867\n        return true;                                                             // 868\n      };                                                                         // 869\n                                                                                 // 870\n      while (r--) {                                                              // 871\n        var points = getPointsAtRadius(maxRadius - r);                           // 872\n                                                                                 // 873\n        if (settings.shuffle) {                                                  // 874\n          points = [].concat(points);                                            // 875\n          shuffleArray(points);                                                  // 876\n        }                                                                        // 877\n                                                                                 // 878\n        // Try to fit the words by looking at each point.                        // 879\n        // array.some() will stop and return true                                // 880\n        // when putWordAtPoint() returns true.                                   // 881\n        // If all the points returns false, array.some() returns false.          // 882\n        var drawn = points.some(tryToPutWordAtPoint);                            // 883\n                                                                                 // 884\n        if (drawn) {                                                             // 885\n          // leave putWord() and return true                                     // 886\n          return true;                                                           // 887\n        }                                                                        // 888\n      }                                                                          // 889\n      // we tried all distances but text won't fit, return false                 // 890\n      return false;                                                              // 891\n    };                                                                           // 892\n                                                                                 // 893\n    /* Send DOM event to all elements. Will stop sending event and return        // 894\n       if the previous one is canceled (for cancelable events). */               // 895\n    var sendEvent = function sendEvent(type, cancelable, detail) {               // 896\n      if (cancelable) {                                                          // 897\n        return !elements.some(function(el) {                                     // 898\n          var evt = document.createEvent('CustomEvent');                         // 899\n          evt.initCustomEvent(type, true, cancelable, detail || {});             // 900\n          return !el.dispatchEvent(evt);                                         // 901\n        }, this);                                                                // 902\n      } else {                                                                   // 903\n        elements.forEach(function(el) {                                          // 904\n          var evt = document.createEvent('CustomEvent');                         // 905\n          evt.initCustomEvent(type, true, cancelable, detail || {});             // 906\n          el.dispatchEvent(evt);                                                 // 907\n        }, this);                                                                // 908\n      }                                                                          // 909\n    };                                                                           // 910\n                                                                                 // 911\n    /* Start drawing on a canvas */                                              // 912\n    var start = function start() {                                               // 913\n      // For dimensions, clearCanvas etc.,                                       // 914\n      // we only care about the first element.                                   // 915\n      var canvas = elements[0];                                                  // 916\n                                                                                 // 917\n      if (canvas.getContext) {                                                   // 918\n        ngx = Math.floor(canvas.width / g);                                      // 919\n        ngy = Math.floor(canvas.height / g);                                     // 920\n      } else {                                                                   // 921\n        var rect = canvas.getBoundingClientRect();                               // 922\n        ngx = Math.floor(rect.width / g);                                        // 923\n        ngy = Math.floor(rect.height / g);                                       // 924\n      }                                                                          // 925\n                                                                                 // 926\n      // Sending a wordcloudstart event which cause the previous loop to stop.   // 927\n      // Do nothing if the event is canceled.                                    // 928\n      if (!sendEvent('wordcloudstart', true)) {                                  // 929\n        return;                                                                  // 930\n      }                                                                          // 931\n                                                                                 // 932\n      // Determine the center of the word cloud                                  // 933\n      center = (settings.origin) ?                                               // 934\n        [settings.origin[0]/g, settings.origin[1]/g] :                           // 935\n        [ngx / 2, ngy / 2];                                                      // 936\n                                                                                 // 937\n      // Maxium radius to look for space                                         // 938\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));                  // 939\n                                                                                 // 940\n      /* Clear the canvas only if the clearCanvas is set,                        // 941\n         if not, update the grid to the current canvas state */                  // 942\n      grid = [];                                                                 // 943\n                                                                                 // 944\n      var gx, gy, i;                                                             // 945\n      if (!canvas.getContext || settings.clearCanvas) {                          // 946\n        elements.forEach(function(el) {                                          // 947\n          if (el.getContext) {                                                   // 948\n            var ctx = el.getContext('2d');                                       // 949\n            ctx.fillStyle = settings.backgroundColor;                            // 950\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));                   // 951\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));                    // 952\n          } else {                                                               // 953\n            el.textContent = '';                                                 // 954\n            el.style.backgroundColor = settings.backgroundColor;                 // 955\n          }                                                                      // 956\n        });                                                                      // 957\n                                                                                 // 958\n        /* fill the grid with empty state */                                     // 959\n        gx = ngx;                                                                // 960\n        while (gx--) {                                                           // 961\n          grid[gx] = [];                                                         // 962\n          gy = ngy;                                                              // 963\n          while (gy--) {                                                         // 964\n            grid[gx][gy] = true;                                                 // 965\n          }                                                                      // 966\n        }                                                                        // 967\n      } else {                                                                   // 968\n        /* Determine bgPixel by creating                                         // 969\n           another canvas and fill the specified background color. */            // 970\n        var bctx = document.createElement('canvas').getContext('2d');            // 971\n                                                                                 // 972\n        bctx.fillStyle = settings.backgroundColor;                               // 973\n        bctx.fillRect(0, 0, 1, 1);                                               // 974\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;                        // 975\n                                                                                 // 976\n        /* Read back the pixels of the canvas we got to tell which part of the   // 977\n           canvas is empty.                                                      // 978\n           (no clearCanvas only works with a canvas, not divs) */                // 979\n        var imageData =                                                          // 980\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;     // 981\n                                                                                 // 982\n        gx = ngx;                                                                // 983\n        var x, y;                                                                // 984\n        while (gx--) {                                                           // 985\n          grid[gx] = [];                                                         // 986\n          gy = ngy;                                                              // 987\n          while (gy--) {                                                         // 988\n            y = g;                                                               // 989\n            singleGridLoop: while (y--) {                                        // 990\n              x = g;                                                             // 991\n              while (x--) {                                                      // 992\n                i = 4;                                                           // 993\n                while (i--) {                                                    // 994\n                  if (imageData[((gy * g + y) * ngx * g +                        // 995\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {        // 996\n                    grid[gx][gy] = false;                                        // 997\n                    break singleGridLoop;                                        // 998\n                  }                                                              // 999\n                }                                                                // 1000\n              }                                                                  // 1001\n            }                                                                    // 1002\n            if (grid[gx][gy] !== false) {                                        // 1003\n              grid[gx][gy] = true;                                               // 1004\n            }                                                                    // 1005\n          }                                                                      // 1006\n        }                                                                        // 1007\n                                                                                 // 1008\n        imageData = bctx = bgPixel = undefined;                                  // 1009\n      }                                                                          // 1010\n                                                                                 // 1011\n      // fill the infoGrid with empty state if we need it                        // 1012\n      if (settings.hover || settings.click) {                                    // 1013\n                                                                                 // 1014\n        interactive = true;                                                      // 1015\n                                                                                 // 1016\n        /* fill the grid with empty state */                                     // 1017\n        gx = ngx + 1;                                                            // 1018\n        while (gx--) {                                                           // 1019\n          infoGrid[gx] = [];                                                     // 1020\n        }                                                                        // 1021\n                                                                                 // 1022\n        if (settings.hover) {                                                    // 1023\n          canvas.addEventListener('mousemove', wordcloudhover);                  // 1024\n        }                                                                        // 1025\n                                                                                 // 1026\n        if (settings.click) {                                                    // 1027\n          canvas.addEventListener('click', wordcloudclick);                      // 1028\n        }                                                                        // 1029\n                                                                                 // 1030\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {   // 1031\n          canvas.removeEventListener('wordcloudstart', stopInteraction);         // 1032\n                                                                                 // 1033\n          canvas.removeEventListener('mousemove', wordcloudhover);               // 1034\n          canvas.removeEventListener('click', wordcloudclick);                   // 1035\n          hovered = undefined;                                                   // 1036\n        });                                                                      // 1037\n      }                                                                          // 1038\n                                                                                 // 1039\n      i = 0;                                                                     // 1040\n      var loopingFunction, stoppingFunction;                                     // 1041\n      if (settings.wait !== 0) {                                                 // 1042\n        loopingFunction = window.setTimeout;                                     // 1043\n        stoppingFunction = window.clearTimeout;                                  // 1044\n      } else {                                                                   // 1045\n        loopingFunction = window.setImmediate;                                   // 1046\n        stoppingFunction = window.clearImmediate;                                // 1047\n      }                                                                          // 1048\n                                                                                 // 1049\n      var addEventListener = function addEventListener(type, listener) {         // 1050\n        elements.forEach(function(el) {                                          // 1051\n          el.addEventListener(type, listener);                                   // 1052\n        }, this);                                                                // 1053\n      };                                                                         // 1054\n                                                                                 // 1055\n      var removeEventListener = function removeEventListener(type, listener) {   // 1056\n        elements.forEach(function(el) {                                          // 1057\n          el.removeEventListener(type, listener);                                // 1058\n        }, this);                                                                // 1059\n      };                                                                         // 1060\n                                                                                 // 1061\n      var anotherWordCloudStart = function anotherWordCloudStart() {             // 1062\n        removeEventListener('wordcloudstart', anotherWordCloudStart);            // 1063\n        stoppingFunction(timer);                                                 // 1064\n      };                                                                         // 1065\n                                                                                 // 1066\n      addEventListener('wordcloudstart', anotherWordCloudStart);                 // 1067\n                                                                                 // 1068\n      var timer = loopingFunction(function loop() {                              // 1069\n        if (i >= settings.list.length) {                                         // 1070\n          stoppingFunction(timer);                                               // 1071\n          sendEvent('wordcloudstop', false);                                     // 1072\n          removeEventListener('wordcloudstart', anotherWordCloudStart);          // 1073\n                                                                                 // 1074\n          return;                                                                // 1075\n        }                                                                        // 1076\n        escapeTime = (new Date()).getTime();                                     // 1077\n        var drawn = putWord(settings.list[i]);                                   // 1078\n        var canceled = !sendEvent('wordclouddrawn', true, {                      // 1079\n          item: settings.list[i], drawn: drawn });                               // 1080\n        if (exceedTime() || canceled) {                                          // 1081\n          stoppingFunction(timer);                                               // 1082\n          settings.abort();                                                      // 1083\n          sendEvent('wordcloudabort', false);                                    // 1084\n          sendEvent('wordcloudstop', false);                                     // 1085\n          removeEventListener('wordcloudstart', anotherWordCloudStart);          // 1086\n          return;                                                                // 1087\n        }                                                                        // 1088\n        i++;                                                                     // 1089\n        timer = loopingFunction(loop, settings.wait);                            // 1090\n      }, settings.wait);                                                         // 1091\n    };                                                                           // 1092\n                                                                                 // 1093\n    // All set, start the drawing                                                // 1094\n    start();                                                                     // 1095\n  };                                                                             // 1096\n                                                                                 // 1097\n  WordCloud.isSupported = isSupported;                                           // 1098\n  WordCloud.miniumFontSize = miniumFontSize;                                     // 1099\n                                                                                 // 1100\n  // Expose the library as an AMD module                                         // 1101\n  if (typeof global.define === 'function' && global.define.amd) {                // 1102\n    global.define('wordcloud', [], function() { return WordCloud; });            // 1103\n  } else {                                                                       // 1104\n    global.WordCloud = WordCloud;                                                // 1105\n  }                                                                              // 1106\n                                                                                 // 1107\n})(window);                                                                      // 1108\n                                                                                 // 1109\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/overture8:wordcloud2/overture8:wordcloud2.js                         //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n// Write your package code here!                                                 // 1\n                                                                                 // 2\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]