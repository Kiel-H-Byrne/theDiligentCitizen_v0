{"version":3,"sources":["meteor://ðŸ’»app/packages/overture8_wordcloud2/packages/overture8_wordcloud2.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG","file":"/packages/overture8_wordcloud2.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/overture8:wordcloud2/wordcloud2.js                                   //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n/*!                                                                              // 1\n * wordcloud2.js                                                                 // 2\n * http://timdream.org/wordcloud2.js/                                            // 3\n *                                                                               // 4\n * Copyright 2011 - 2013 Tim Chien                                               // 5\n * Released under the MIT license                                                // 6\n */                                                                              // 7\n                                                                                 // 8\n'use strict';                                                                    // 9\n                                                                                 // 10\n// setImmediate                                                                  // 11\nif (!window.setImmediate) {                                                      // 12\n  window.setImmediate = (function setupSetImmediate() {                          // 13\n    return window.msSetImmediate ||                                              // 14\n    window.webkitSetImmediate ||                                                 // 15\n    window.mozSetImmediate ||                                                    // 16\n    window.oSetImmediate ||                                                      // 17\n    (function setupSetZeroTimeout() {                                            // 18\n      if (!window.postMessage || !window.addEventListener) {                     // 19\n        return null;                                                             // 20\n      }                                                                          // 21\n                                                                                 // 22\n      var callbacks = [undefined];                                               // 23\n      var message = 'zero-timeout-message';                                      // 24\n                                                                                 // 25\n      // Like setTimeout, but only takes a function argument.  There's           // 26\n      // no time argument (always zero) and no arguments (you have to            // 27\n      // use a closure).                                                         // 28\n      var setZeroTimeout = function setZeroTimeout(callback) {                   // 29\n        var id = callbacks.length;                                               // 30\n        callbacks.push(callback);                                                // 31\n        window.postMessage(message + id.toString(36), '*');                      // 32\n                                                                                 // 33\n        return id;                                                               // 34\n      };                                                                         // 35\n                                                                                 // 36\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {   // 37\n        // Skipping checking event source, retarded IE confused this window      // 38\n        // object with another in the presence of iframe                         // 39\n        if (typeof evt.data !== 'string' ||                                      // 40\n            evt.data.substr(0, message.length) !== message/* ||                  // 41\n            evt.source !== window */) {                                          // 42\n          return;                                                                // 43\n        }                                                                        // 44\n                                                                                 // 45\n        evt.stopImmediatePropagation();                                          // 46\n                                                                                 // 47\n        var id = parseInt(evt.data.substr(message.length), 36);                  // 48\n        if (!callbacks[id]) {                                                    // 49\n          return;                                                                // 50\n        }                                                                        // 51\n                                                                                 // 52\n        callbacks[id]();                                                         // 53\n        callbacks[id] = undefined;                                               // 54\n      }, true);                                                                  // 55\n                                                                                 // 56\n      /* specify clearImmediate() here since we need the scope */                // 57\n      window.clearImmediate = function clearZeroTimeout(id) {                    // 58\n        if (!callbacks[id]) {                                                    // 59\n          return;                                                                // 60\n        }                                                                        // 61\n                                                                                 // 62\n        callbacks[id] = undefined;                                               // 63\n      };                                                                         // 64\n                                                                                 // 65\n      return setZeroTimeout;                                                     // 66\n    })() ||                                                                      // 67\n    // fallback                                                                  // 68\n    function setImmediateFallback(fn) {                                          // 69\n      window.setTimeout(fn, 0);                                                  // 70\n    };                                                                           // 71\n  })();                                                                          // 72\n}                                                                                // 73\n                                                                                 // 74\nif (!window.clearImmediate) {                                                    // 75\n  window.clearImmediate = (function setupClearImmediate() {                      // 76\n    return window.msClearImmediate ||                                            // 77\n    window.webkitClearImmediate ||                                               // 78\n    window.mozClearImmediate ||                                                  // 79\n    window.oClearImmediate ||                                                    // 80\n    // \"clearZeroTimeout\" is implement on the previous block ||                  // 81\n    // fallback                                                                  // 82\n    function clearImmediateFallback(timer) {                                     // 83\n      window.clearTimeout(timer);                                                // 84\n    };                                                                           // 85\n  })();                                                                          // 86\n}                                                                                // 87\n                                                                                 // 88\n(function(global) {                                                              // 89\n                                                                                 // 90\n  // Check if WordCloud can run on this browser                                  // 91\n  var isSupported = (function isSupported() {                                    // 92\n    var canvas = document.createElement('canvas');                               // 93\n    if (!canvas || !canvas.getContext) {                                         // 94\n      return false;                                                              // 95\n    }                                                                            // 96\n                                                                                 // 97\n    var ctx = canvas.getContext('2d');                                           // 98\n    if (!ctx.getImageData) {                                                     // 99\n      return false;                                                              // 100\n    }                                                                            // 101\n    if (!ctx.fillText) {                                                         // 102\n      return false;                                                              // 103\n    }                                                                            // 104\n                                                                                 // 105\n    if (!Array.prototype.some) {                                                 // 106\n      return false;                                                              // 107\n    }                                                                            // 108\n    if (!Array.prototype.push) {                                                 // 109\n      return false;                                                              // 110\n    }                                                                            // 111\n                                                                                 // 112\n    return true;                                                                 // 113\n  }());                                                                          // 114\n                                                                                 // 115\n  // Find out if the browser impose minium font size by                          // 116\n  // drawing small texts on a canvas and measure it's width.                     // 117\n  var miniumFontSize = (function getMiniumFontSize() {                           // 118\n    if (!isSupported) {                                                          // 119\n      return;                                                                    // 120\n    }                                                                            // 121\n                                                                                 // 122\n    var ctx = document.createElement('canvas').getContext('2d');                 // 123\n                                                                                 // 124\n    // start from 20                                                             // 125\n    var size = 20;                                                               // 126\n                                                                                 // 127\n    // two sizes to measure                                                      // 128\n    var hanWidth, mWidth;                                                        // 129\n                                                                                 // 130\n    while (size) {                                                               // 131\n      ctx.font = size.toString(10) + 'px sans-serif';                            // 132\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&                      // 133\n          (ctx.measureText('m').width) === mWidth) {                             // 134\n        return (size + 1);                                                       // 135\n      }                                                                          // 136\n                                                                                 // 137\n      hanWidth = ctx.measureText('\\uFF37').width;                                // 138\n      mWidth = ctx.measureText('m').width;                                       // 139\n                                                                                 // 140\n      size--;                                                                    // 141\n    }                                                                            // 142\n                                                                                 // 143\n    return 0;                                                                    // 144\n  })();                                                                          // 145\n                                                                                 // 146\n  // Based on http://jsfromhell.com/array/shuffle                                // 147\n  var shuffleArray = function shuffleArray(arr) {                                // 148\n    for (var j, x, i = arr.length; i;                                            // 149\n      j = Math.floor(Math.random() * i),                                         // 150\n      x = arr[--i], arr[i] = arr[j],                                             // 151\n      arr[j] = x) {}                                                             // 152\n    return arr;                                                                  // 153\n  };                                                                             // 154\n                                                                                 // 155\n  var WordCloud = function WordCloud(elements, options) {                        // 156\n    if (!isSupported) {                                                          // 157\n      return;                                                                    // 158\n    }                                                                            // 159\n                                                                                 // 160\n    if (!Array.isArray(elements)) {                                              // 161\n      elements = [elements];                                                     // 162\n    }                                                                            // 163\n                                                                                 // 164\n    elements.forEach(function(el, i) {                                           // 165\n      if (typeof el === 'string') {                                              // 166\n        elements[i] = document.getElementById(el);                               // 167\n        if (!elements[i]) {                                                      // 168\n          throw 'The element id specified is not found.';                        // 169\n        }                                                                        // 170\n      } else if (!el.tagName && !el.appendChild) {                               // 171\n        throw 'You must pass valid HTML elements, or ID of the element.';        // 172\n      }                                                                          // 173\n    });                                                                          // 174\n                                                                                 // 175\n    /* Default values to be overwritten by options object */                     // 176\n    var settings = {                                                             // 177\n      list: [],                                                                  // 178\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"å¾®è»Ÿæ­£é»‘é«”\", ' +                      // 179\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',       // 180\n      fontWeight: 'normal',                                                      // 181\n      color: 'random-dark',                                                      // 182\n      minSize: 0, // 0 to disable                                                // 183\n      weightFactor: 1,                                                           // 184\n      clearCanvas: true,                                                         // 185\n      backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)         // 186\n                                                                                 // 187\n      gridSize: 8,                                                               // 188\n      origin: null,                                                              // 189\n                                                                                 // 190\n      drawMask: false,                                                           // 191\n      maskColor: 'rgba(255,0,0,0.3)',                                            // 192\n      maskGapWidth: 0.3,                                                         // 193\n                                                                                 // 194\n      wait: 0,                                                                   // 195\n      abortThreshold: 0, // disabled                                             // 196\n      abort: function noop() {},                                                 // 197\n                                                                                 // 198\n      minRotation: - Math.PI / 2,                                                // 199\n      maxRotation: Math.PI / 2,                                                  // 200\n                                                                                 // 201\n      shuffle: true,                                                             // 202\n      rotateRatio: 0.1,                                                          // 203\n                                                                                 // 204\n      shape: 'circle',                                                           // 205\n      ellipticity: 0.65,                                                         // 206\n                                                                                 // 207\n      hover: null,                                                               // 208\n      click: null                                                                // 209\n    };                                                                           // 210\n                                                                                 // 211\n    if (options) {                                                               // 212\n      for (var key in options) {                                                 // 213\n        if (key in settings) {                                                   // 214\n          settings[key] = options[key];                                          // 215\n        }                                                                        // 216\n      }                                                                          // 217\n    }                                                                            // 218\n                                                                                 // 219\n    /* Convert weightFactor into a function */                                   // 220\n    if (typeof settings.weightFactor !== 'function') {                           // 221\n      var factor = settings.weightFactor;                                        // 222\n      settings.weightFactor = function weightFactor(pt) {                        // 223\n        return pt * factor; //in px                                              // 224\n      };                                                                         // 225\n    }                                                                            // 226\n                                                                                 // 227\n    /* Convert shape into a function */                                          // 228\n    if (typeof settings.shape !== 'function') {                                  // 229\n      switch (settings.shape) {                                                  // 230\n        case 'circle':                                                           // 231\n        /* falls through */                                                      // 232\n        default:                                                                 // 233\n          // 'circle' is the default and a shortcut in the code loop.            // 234\n          settings.shape = 'circle';                                             // 235\n          break;                                                                 // 236\n                                                                                 // 237\n        case 'cardioid':                                                         // 238\n          settings.shape = function shapeCardioid(theta) {                       // 239\n            return 1 - Math.sin(theta);                                          // 240\n          };                                                                     // 241\n          break;                                                                 // 242\n                                                                                 // 243\n        /*                                                                       // 244\n                                                                                 // 245\n        To work out an X-gon, one has to calculate \"m\",                          // 246\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))                // 247\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28 // 248\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29                   // 249\n                                                                                 // 250\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))        // 251\n        where t' equals to mod(t, 2PI/X);                                        // 252\n                                                                                 // 253\n        */                                                                       // 254\n                                                                                 // 255\n        case 'diamond':                                                          // 256\n        case 'square':                                                           // 257\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+   // 258\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D   // 259\n          // +0+..+2*PI                                                          // 260\n          settings.shape = function shapeSquare(theta) {                         // 261\n            var thetaPrime = theta % (2 * Math.PI / 4);                          // 262\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));            // 263\n          };                                                                     // 264\n          break;                                                                 // 265\n                                                                                 // 266\n        case 'triangle-forward':                                                 // 267\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+   // 268\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29   // 269\n          // %29%29%2C+t+%3D+0+..+2*PI                                           // 270\n          settings.shape = function shapeTriangle(theta) {                       // 271\n            var thetaPrime = theta % (2 * Math.PI / 3);                          // 272\n            return 1 / (Math.cos(thetaPrime) +                                   // 273\n                        Math.sqrt(3) * Math.sin(thetaPrime));                    // 274\n          };                                                                     // 275\n          break;                                                                 // 276\n                                                                                 // 277\n        case 'triangle':                                                         // 278\n        case 'triangle-upright':                                                 // 279\n          settings.shape = function shapeTriangle(theta) {                       // 280\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);      // 281\n            return 1 / (Math.cos(thetaPrime) +                                   // 282\n                        Math.sqrt(3) * Math.sin(thetaPrime));                    // 283\n          };                                                                     // 284\n          break;                                                                 // 285\n                                                                                 // 286\n        case 'pentagon':                                                         // 287\n          settings.shape = function shapePentagon(theta) {                       // 288\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);                // 289\n            return 1 / (Math.cos(thetaPrime) +                                   // 290\n                        0.726543 * Math.sin(thetaPrime));                        // 291\n          };                                                                     // 292\n          break;                                                                 // 293\n                                                                                 // 294\n        case 'star':                                                             // 295\n          settings.shape = function shapeStar(theta) {                           // 296\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);               // 297\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) { // 298\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +            // 299\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));  // 300\n            } else {                                                             // 301\n              return 1 / (Math.cos(thetaPrime) +                                 // 302\n                          3.07768 * Math.sin(thetaPrime));                       // 303\n            }                                                                    // 304\n          };                                                                     // 305\n          break;                                                                 // 306\n      }                                                                          // 307\n    }                                                                            // 308\n                                                                                 // 309\n    /* Make sure gridSize is a whole number and is not smaller than 4px */       // 310\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);              // 311\n                                                                                 // 312\n    /* shorthand */                                                              // 313\n    var g = settings.gridSize;                                                   // 314\n    var maskRectWidth = g - settings.maskGapWidth;                               // 315\n                                                                                 // 316\n    /* normalize rotation settings */                                            // 317\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);   // 318\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);      // 319\n                                                                                 // 320\n    /* information/object available to all functions, set when start() */        // 321\n    var grid, // 2d array containing filling information                         // 322\n      ngx, ngy, // width and height of the grid                                  // 323\n      center, // position of the center of the cloud                             // 324\n      maxRadius;                                                                 // 325\n                                                                                 // 326\n    /* timestamp for measuring each putWord() action */                          // 327\n    var escapeTime;                                                              // 328\n                                                                                 // 329\n    /* function for getting the color of the text */                             // 330\n    var getTextColor;                                                            // 331\n    switch (settings.color) {                                                    // 332\n      case 'random-dark':                                                        // 333\n        getTextColor = function getRandomDarkColor() {                           // 334\n          return 'rgb(' +                                                        // 335\n            Math.floor(Math.random() * 128).toString(10) + ',' +                 // 336\n            Math.floor(Math.random() * 128).toString(10) + ',' +                 // 337\n            Math.floor(Math.random() * 128).toString(10) + ')';                  // 338\n        };                                                                       // 339\n        break;                                                                   // 340\n                                                                                 // 341\n      case 'random-light':                                                       // 342\n        getTextColor = function getRandomLightColor() {                          // 343\n          return 'rgb(' +                                                        // 344\n            Math.floor(Math.random() * 128 + 128).toString(10) + ',' +           // 345\n            Math.floor(Math.random() * 128 + 128).toString(10) + ',' +           // 346\n            Math.floor(Math.random() * 128 + 128).toString(10) + ')';            // 347\n        };                                                                       // 348\n        break;                                                                   // 349\n                                                                                 // 350\n      default:                                                                   // 351\n        if (typeof settings.color === 'function') {                              // 352\n          getTextColor = settings.color;                                         // 353\n        }                                                                        // 354\n        break;                                                                   // 355\n    }                                                                            // 356\n                                                                                 // 357\n    /* Interactive */                                                            // 358\n    var interactive = false;                                                     // 359\n    var infoGrid = [];                                                           // 360\n    var hovered;                                                                 // 361\n                                                                                 // 362\n    var getInfoGridFromMouseEvent = function getInfoGridFromMouseEvent(evt) {    // 363\n      var canvas = evt.currentTarget;                                            // 364\n      var rect = canvas.getBoundingClientRect();                                 // 365\n      var eventX = evt.clientX - rect.left;                                      // 366\n      var eventY = evt.clientY - rect.top;                                       // 367\n                                                                                 // 368\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);       // 369\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);     // 370\n                                                                                 // 371\n      return infoGrid[x][y];                                                     // 372\n    };                                                                           // 373\n                                                                                 // 374\n    var wordcloudhover = function wordcloudhover(evt) {                          // 375\n      var info = getInfoGridFromMouseEvent(evt);                                 // 376\n                                                                                 // 377\n      if (hovered === info) {                                                    // 378\n        return;                                                                  // 379\n      }                                                                          // 380\n                                                                                 // 381\n      hovered = info;                                                            // 382\n      if (!info) {                                                               // 383\n        settings.hover(undefined, undefined, evt);                               // 384\n                                                                                 // 385\n        return;                                                                  // 386\n      }                                                                          // 387\n                                                                                 // 388\n      settings.hover(info.item, info.dimension, evt);                            // 389\n                                                                                 // 390\n    };                                                                           // 391\n                                                                                 // 392\n    var wordcloudclick = function wordcloudclick(evt) {                          // 393\n      var info = getInfoGridFromMouseEvent(evt);                                 // 394\n      if (!info) {                                                               // 395\n        return;                                                                  // 396\n      }                                                                          // 397\n                                                                                 // 398\n      settings.click(info.item, info.dimension, evt);                            // 399\n    };                                                                           // 400\n                                                                                 // 401\n    /* Get points on the grid for a given radius away from the center */         // 402\n    var pointsAtRadius = [];                                                     // 403\n    var getPointsAtRadius = function getPointsAtRadius(radius) {                 // 404\n      if (pointsAtRadius[radius]) {                                              // 405\n        return pointsAtRadius[radius];                                           // 406\n      }                                                                          // 407\n                                                                                 // 408\n      // Look for these number of points on each radius                          // 409\n      var T = radius * 8;                                                        // 410\n                                                                                 // 411\n      // Getting all the points at this radius                                   // 412\n      var t = T;                                                                 // 413\n      var points = [];                                                           // 414\n                                                                                 // 415\n      if (radius === 0) {                                                        // 416\n        points.push([center[0], center[1], 0]);                                  // 417\n      }                                                                          // 418\n                                                                                 // 419\n      while (t--) {                                                              // 420\n        // distort the radius to put the cloud in shape                          // 421\n        var rx = 1;                                                              // 422\n        if (settings.shape !== 'circle') {                                       // 423\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1                    // 424\n        }                                                                        // 425\n                                                                                 // 426\n        // Push [x, y, t]; t is used solely for getTextColor()                   // 427\n        points.push([                                                            // 428\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),              // 429\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *             // 430\n            settings.ellipticity,                                                // 431\n          t / T * 2 * Math.PI]);                                                 // 432\n      }                                                                          // 433\n                                                                                 // 434\n      pointsAtRadius[radius] = points;                                           // 435\n      return points;                                                             // 436\n    };                                                                           // 437\n                                                                                 // 438\n    /* Return true if we had spent too much time */                              // 439\n    var exceedTime = function exceedTime() {                                     // 440\n      return ((settings.abortThreshold > 0) &&                                   // 441\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold));        // 442\n    };                                                                           // 443\n                                                                                 // 444\n    /* Get the deg of rotation according to settings, and luck. */               // 445\n    var getRotateDeg = function getRotateDeg() {                                 // 446\n      if (settings.rotateRatio === 0) {                                          // 447\n        return 0;                                                                // 448\n      }                                                                          // 449\n                                                                                 // 450\n      if (Math.random() > settings.rotateRatio) {                                // 451\n        return 0;                                                                // 452\n      }                                                                          // 453\n                                                                                 // 454\n      if (rotationRange === 0) {                                                 // 455\n        return minRotation;                                                      // 456\n      }                                                                          // 457\n                                                                                 // 458\n      return minRotation + Math.random() * rotationRange;                        // 459\n    };                                                                           // 460\n                                                                                 // 461\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {            // 462\n      // calculate the acutal font size                                          // 463\n      // fontSize === 0 means weightFactor function wants the text skipped,      // 464\n      // and size < minSize means we cannot draw the text.                       // 465\n      var debug = false;                                                         // 466\n      var fontSize = settings.weightFactor(weight);                              // 467\n      if (fontSize <= settings.minSize) {                                        // 468\n        return false;                                                            // 469\n      }                                                                          // 470\n                                                                                 // 471\n      // Scale factor here is to make sure fillText is not limited by            // 472\n      // the minium font size set by browser.                                    // 473\n      // It will always be 1 or 2n.                                              // 474\n      var mu = 1;                                                                // 475\n      if (fontSize < miniumFontSize) {                                           // 476\n        mu = (function calculateScaleFactor() {                                  // 477\n          var mu = 2;                                                            // 478\n          while (mu * fontSize < miniumFontSize) {                               // 479\n            mu += 2;                                                             // 480\n          }                                                                      // 481\n          return mu;                                                             // 482\n        })();                                                                    // 483\n      }                                                                          // 484\n                                                                                 // 485\n      var fcanvas = document.createElement('canvas');                            // 486\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });         // 487\n                                                                                 // 488\n      fctx.font = settings.fontWeight + ' ' +                                    // 489\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;              // 490\n                                                                                 // 491\n      // Estimate the dimension of the text with measureText().                  // 492\n      var fw = fctx.measureText(word).width / mu;                                // 493\n      var fh = Math.max(fontSize * mu,                                           // 494\n                        fctx.measureText('m').width,                             // 495\n                        fctx.measureText('\\uFF37').width) / mu;                  // 496\n                                                                                 // 497\n      // Create a boundary box that is larger than our estimates,                // 498\n      // so text don't get cut of (it sill might)                                // 499\n      var boxWidth = fw + fh * 2;                                                // 500\n      var boxHeight = fh * 3;                                                    // 501\n      var fgw = Math.ceil(boxWidth / g);                                         // 502\n      var fgh = Math.ceil(boxHeight / g);                                        // 503\n      boxWidth = fgw * g;                                                        // 504\n      boxHeight = fgh * g;                                                       // 505\n                                                                                 // 506\n      // Calculate the proper offsets to make the text centered at               // 507\n      // the preferred position.                                                 // 508\n                                                                                 // 509\n      // This is simply half of the width.                                       // 510\n      var fillTextOffsetX = - fw / 2;                                            // 511\n      // Instead of moving the box to the exact middle of the preferred          // 512\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look     // 513\n      // vertical centered.                                                      // 514\n      var fillTextOffsetY = - fh * 0.4;                                          // 515\n                                                                                 // 516\n      // Calculate the actual dimension of the canvas, considering the rotation. // 517\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +            // 518\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);      // 519\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +            // 520\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);      // 521\n      var width = cgw * g;                                                       // 522\n      var height = cgh * g;                                                      // 523\n                                                                                 // 524\n      fcanvas.setAttribute('width', width);                                      // 525\n      fcanvas.setAttribute('height', height);                                    // 526\n                                                                                 // 527\n      if (debug) {                                                               // 528\n        // Attach fcanvas to the DOM                                             // 529\n        document.body.appendChild(fcanvas);                                      // 530\n        // Save it's state so that we could restore and draw the grid correctly. // 531\n        fctx.save();                                                             // 532\n      }                                                                          // 533\n                                                                                 // 534\n      // Scale the canvas with |mu|.                                             // 535\n      fctx.scale(1 / mu, 1 / mu);                                                // 536\n      fctx.translate(width * mu / 2, height * mu / 2);                           // 537\n      fctx.rotate(- rotateDeg);                                                  // 538\n                                                                                 // 539\n      // Once the width/height is set, ctx info will be reset.                   // 540\n      // Set it again here.                                                      // 541\n      fctx.font = settings.fontWeight + ' ' +                                    // 542\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;              // 543\n                                                                                 // 544\n      // Fill the text into the fcanvas.                                         // 545\n      // XXX: We cannot because textBaseline = 'top' here because                // 546\n      // Firefox and Chrome uses different default line-height for canvas.       // 547\n      // Please read https://bugzil.la/737852#c6.                                // 548\n      // Here, we use textBaseline = 'middle' and draw the text at exactly       // 549\n      // 0.5 * fontSize lower.                                                   // 550\n      fctx.fillStyle = '#000';                                                   // 551\n      fctx.textBaseline = 'middle';                                              // 552\n      fctx.fillText(word, fillTextOffsetX * mu,                                  // 553\n                    (fillTextOffsetY + fontSize * 0.5) * mu);                    // 554\n                                                                                 // 555\n      // Get the pixels of the text                                              // 556\n      var imageData = fctx.getImageData(0, 0, width, height).data;               // 557\n                                                                                 // 558\n      if (exceedTime()) {                                                        // 559\n        return false;                                                            // 560\n      }                                                                          // 561\n                                                                                 // 562\n      if (debug) {                                                               // 563\n        // Draw the box of the original estimation                               // 564\n        fctx.strokeRect(fillTextOffsetX * mu,                                    // 565\n                        fillTextOffsetY, fw * mu, fh * mu);                      // 566\n        fctx.restore();                                                          // 567\n      }                                                                          // 568\n                                                                                 // 569\n      // Read the pixels and save the information to the occupied array          // 570\n      var occupied = [];                                                         // 571\n      var gx = cgw, gy, x, y;                                                    // 572\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];                         // 573\n      while (gx--) {                                                             // 574\n        gy = cgh;                                                                // 575\n        while (gy--) {                                                           // 576\n          y = g;                                                                 // 577\n          singleGridLoop: {                                                      // 578\n            while (y--) {                                                        // 579\n              x = g;                                                             // 580\n              while (x--) {                                                      // 581\n                if (imageData[((gy * g + y) * width +                            // 582\n                               (gx * g + x)) * 4 + 3]) {                         // 583\n                  occupied.push([gx, gy]);                                       // 584\n                                                                                 // 585\n                  if (gx < bounds[3]) {                                          // 586\n                    bounds[3] = gx;                                              // 587\n                  }                                                              // 588\n                  if (gx > bounds[1]) {                                          // 589\n                    bounds[1] = gx;                                              // 590\n                  }                                                              // 591\n                  if (gy < bounds[0]) {                                          // 592\n                    bounds[0] = gy;                                              // 593\n                  }                                                              // 594\n                  if (gy > bounds[2]) {                                          // 595\n                    bounds[2] = gy;                                              // 596\n                  }                                                              // 597\n                                                                                 // 598\n                  if (debug) {                                                   // 599\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';                     // 600\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);             // 601\n                  }                                                              // 602\n                  break singleGridLoop;                                          // 603\n                }                                                                // 604\n              }                                                                  // 605\n            }                                                                    // 606\n            if (debug) {                                                         // 607\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';                           // 608\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);                   // 609\n            }                                                                    // 610\n          }                                                                      // 611\n        }                                                                        // 612\n      }                                                                          // 613\n                                                                                 // 614\n      if (debug) {                                                               // 615\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';                                 // 616\n        fctx.fillRect(bounds[3] * g,                                             // 617\n                      bounds[0] * g,                                             // 618\n                      (bounds[1] - bounds[3] + 1) * g,                           // 619\n                      (bounds[2] - bounds[0] + 1) * g);                          // 620\n      }                                                                          // 621\n                                                                                 // 622\n      // Return information needed to create the text on the real canvas         // 623\n      return {                                                                   // 624\n        mu: mu,                                                                  // 625\n        occupied: occupied,                                                      // 626\n        bounds: bounds,                                                          // 627\n        gw: cgw,                                                                 // 628\n        gh: cgh,                                                                 // 629\n        fillTextOffsetX: fillTextOffsetX,                                        // 630\n        fillTextOffsetY: fillTextOffsetY,                                        // 631\n        fillTextWidth: fw,                                                       // 632\n        fillTextHeight: fh,                                                      // 633\n        fontSize: fontSize                                                       // 634\n      };                                                                         // 635\n    };                                                                           // 636\n                                                                                 // 637\n    /* Determine if there is room available in the given dimension */            // 638\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {             // 639\n      // Go through the occupied points,                                         // 640\n      // return false if the space is not available.                             // 641\n      var i = occupied.length;                                                   // 642\n      while (i--) {                                                              // 643\n        var px = gx + occupied[i][0];                                            // 644\n        var py = gy + occupied[i][1];                                            // 645\n                                                                                 // 646\n        if (px >= ngx || py >= ngy || px < 0 || py < 0 || !grid[px][py]) {       // 647\n          return false;                                                          // 648\n        }                                                                        // 649\n      }                                                                          // 650\n      return true;                                                               // 651\n    };                                                                           // 652\n                                                                                 // 653\n    /* Actually draw the text on the grid */                                     // 654\n    var drawText = function drawText(gx, gy, info, word, weight,                 // 655\n                                     distance, theta, rotateDeg, attributes) {   // 656\n                                                                                 // 657\n      var fontSize = info.fontSize;                                              // 658\n      var color;                                                                 // 659\n      if (getTextColor) {                                                        // 660\n        color = getTextColor(word, weight, fontSize, distance, theta);           // 661\n      } else {                                                                   // 662\n        color = settings.color;                                                  // 663\n      }                                                                          // 664\n                                                                                 // 665\n      var dimension;                                                             // 666\n      var bounds = info.bounds;                                                  // 667\n      dimension = {                                                              // 668\n        x: (gx + bounds[3]) * g,                                                 // 669\n        y: (gy + bounds[0]) * g,                                                 // 670\n        w: (bounds[1] - bounds[3] + 1) * g,                                      // 671\n        h: (bounds[2] - bounds[0] + 1) * g                                       // 672\n      };                                                                         // 673\n                                                                                 // 674\n      elements.forEach(function(el) {                                            // 675\n        if (el.getContext) {                                                     // 676\n          var ctx = el.getContext('2d');                                         // 677\n          var mu = info.mu;                                                      // 678\n                                                                                 // 679\n          // Save the current state before messing it                            // 680\n          ctx.save();                                                            // 681\n          ctx.scale(1 / mu, 1 / mu);                                             // 682\n                                                                                 // 683\n          ctx.font = settings.fontWeight + ' ' +                                 // 684\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // 685\n          ctx.fillStyle = color;                                                 // 686\n                                                                                 // 687\n          // Translate the canvas position to the origin coordinate of where     // 688\n          // the text should be put.                                             // 689\n          ctx.translate((gx + info.gw / 2) * g * mu,                             // 690\n                        (gy + info.gh / 2) * g * mu);                            // 691\n                                                                                 // 692\n          if (rotateDeg !== 0) {                                                 // 693\n            ctx.rotate(- rotateDeg);                                             // 694\n          }                                                                      // 695\n                                                                                 // 696\n          // Finally, fill the text.                                             // 697\n                                                                                 // 698\n          // XXX: We cannot because textBaseline = 'top' here because            // 699\n          // Firefox and Chrome uses different default line-height for canvas.   // 700\n          // Please read https://bugzil.la/737852#c6.                            // 701\n          // Here, we use textBaseline = 'middle' and draw the text at exactly   // 702\n          // 0.5 * fontSize lower.                                               // 703\n          ctx.textBaseline = 'middle';                                           // 704\n          ctx.fillText(word, info.fillTextOffsetX * mu,                          // 705\n                             (info.fillTextOffsetY + fontSize * 0.5) * mu);      // 706\n                                                                                 // 707\n          // The below box is always matches how <span>s are positioned          // 708\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,          // 709\n            info.fillTextWidth, info.fillTextHeight); */                         // 710\n                                                                                 // 711\n          // Restore the state.                                                  // 712\n          ctx.restore();                                                         // 713\n        } else {                                                                 // 714\n          // drawText on DIV element                                             // 715\n          var span = document.createElement('span');                             // 716\n          var transformRule = '';                                                // 717\n          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';   // 718\n          if (info.mu !== 1) {                                                   // 719\n            transformRule +=                                                     // 720\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +               // 721\n              'scale(' + (1 / info.mu) + ')';                                    // 722\n          }                                                                      // 723\n          var styleRules = {                                                     // 724\n            'position': 'absolute',                                              // 725\n            'display': 'block',                                                  // 726\n            'font': settings.fontWeight + ' ' +                                  // 727\n                    (fontSize * info.mu) + 'px ' + settings.fontFamily,          // 728\n            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',      // 729\n            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',       // 730\n            'width': info.fillTextWidth + 'px',                                  // 731\n            'height': info.fillTextHeight + 'px',                                // 732\n            'color': color,                                                      // 733\n            'lineHeight': fontSize + 'px',                                       // 734\n            'whiteSpace': 'nowrap',                                              // 735\n            'transform': transformRule,                                          // 736\n            'webkitTransform': transformRule,                                    // 737\n            'msTransform': transformRule,                                        // 738\n            'transformOrigin': '50% 40%',                                        // 739\n            'webkitTransformOrigin': '50% 40%',                                  // 740\n            'msTransformOrigin': '50% 40%'                                       // 741\n          };                                                                     // 742\n          span.textContent = word;                                               // 743\n          for (var cssProp in styleRules) {                                      // 744\n            span.style[cssProp] = styleRules[cssProp];                           // 745\n          }                                                                      // 746\n          if (attributes) {                                                      // 747\n            for (var attribute in attributes) {                                  // 748\n              span.setAttribute(attribute, attributes[attribute]);               // 749\n            }                                                                    // 750\n          }                                                                      // 751\n          el.appendChild(span);                                                  // 752\n        }                                                                        // 753\n      });                                                                        // 754\n    };                                                                           // 755\n                                                                                 // 756\n    /* Help function to updateGrid */                                            // 757\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {      // 758\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {                              // 759\n        return;                                                                  // 760\n      }                                                                          // 761\n                                                                                 // 762\n      grid[x][y] = false;                                                        // 763\n                                                                                 // 764\n      if (drawMask) {                                                            // 765\n        var ctx = elements[0].getContext('2d');                                  // 766\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);                // 767\n      }                                                                          // 768\n                                                                                 // 769\n      if (interactive) {                                                         // 770\n        infoGrid[x][y] = { item: item, dimension: dimension };                   // 771\n      }                                                                          // 772\n    };                                                                           // 773\n                                                                                 // 774\n    /* Update the filling information of the given space with occupied points.   // 775\n       Draw the mask on the canvas if necessary. */                              // 776\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {           // 777\n      var occupied = info.occupied;                                              // 778\n      var drawMask = settings.drawMask;                                          // 779\n      var ctx;                                                                   // 780\n      if (drawMask) {                                                            // 781\n        ctx = elements[0].getContext('2d');                                      // 782\n        ctx.save();                                                              // 783\n        ctx.fillStyle = settings.maskColor;                                      // 784\n      }                                                                          // 785\n                                                                                 // 786\n      var dimension;                                                             // 787\n      if (interactive) {                                                         // 788\n        var bounds = info.bounds;                                                // 789\n        dimension = {                                                            // 790\n          x: (gx + bounds[3]) * g,                                               // 791\n          y: (gy + bounds[0]) * g,                                               // 792\n          w: (bounds[1] - bounds[3] + 1) * g,                                    // 793\n          h: (bounds[2] - bounds[0] + 1) * g                                     // 794\n        };                                                                       // 795\n      }                                                                          // 796\n                                                                                 // 797\n      var i = occupied.length;                                                   // 798\n      while (i--) {                                                              // 799\n        fillGridAt(gx + occupied[i][0], gy + occupied[i][1],                     // 800\n                   drawMask, dimension, item);                                   // 801\n      }                                                                          // 802\n                                                                                 // 803\n      if (drawMask) {                                                            // 804\n        ctx.restore();                                                           // 805\n      }                                                                          // 806\n    };                                                                           // 807\n                                                                                 // 808\n    /* putWord() processes each item on the list,                                // 809\n       calculate it's size and determine it's position, and actually             // 810\n       put it on the canvas. */                                                  // 811\n    var putWord = function putWord(item) {                                       // 812\n      var word, weight, attributes;                                              // 813\n      if (Array.isArray(item)) {                                                 // 814\n        word = item[0];                                                          // 815\n        weight = item[1];                                                        // 816\n      } else {                                                                   // 817\n        word = item.word;                                                        // 818\n        weight = item.weight;                                                    // 819\n        attributes = item.attributes;                                            // 820\n      }                                                                          // 821\n      var rotateDeg = getRotateDeg();                                            // 822\n                                                                                 // 823\n      // get info needed to put the text onto the canvas                         // 824\n      var info = getTextInfo(word, weight, rotateDeg);                           // 825\n                                                                                 // 826\n      // not getting the info means we shouldn't be drawing this one.            // 827\n      if (!info) {                                                               // 828\n        return false;                                                            // 829\n      }                                                                          // 830\n                                                                                 // 831\n      if (exceedTime()) {                                                        // 832\n        return false;                                                            // 833\n      }                                                                          // 834\n                                                                                 // 835\n      // Skip the loop if we have already know the bounding box of               // 836\n      // word is larger than the canvas.                                         // 837\n      var bounds = info.bounds;                                                  // 838\n      if ((bounds[1] - bounds[3] + 1) > ngx ||                                   // 839\n        (bounds[2] - bounds[0] + 1) > ngy) {                                     // 840\n        return false;                                                            // 841\n      }                                                                          // 842\n                                                                                 // 843\n      // Determine the position to put the text by                               // 844\n      // start looking for the nearest points                                    // 845\n      var r = maxRadius + 1;                                                     // 846\n                                                                                 // 847\n      var tryToPutWordAtPoint = function(gxy) {                                  // 848\n        var gx = Math.floor(gxy[0] - info.gw / 2);                               // 849\n        var gy = Math.floor(gxy[1] - info.gh / 2);                               // 850\n        var gw = info.gw;                                                        // 851\n        var gh = info.gh;                                                        // 852\n                                                                                 // 853\n        // If we cannot fit the text at this position, return false              // 854\n        // and go to the next position.                                          // 855\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {                        // 856\n          return false;                                                          // 857\n        }                                                                        // 858\n                                                                                 // 859\n        // Actually put the text on the canvas                                   // 860\n        drawText(gx, gy, info, word, weight,                                     // 861\n                 (maxRadius - r), gxy[2], rotateDeg, attributes);                // 862\n                                                                                 // 863\n        // Mark the spaces on the grid as filled                                 // 864\n        updateGrid(gx, gy, gw, gh, info, item);                                  // 865\n                                                                                 // 866\n        // Return true so some() will stop and also return true.                 // 867\n        return true;                                                             // 868\n      };                                                                         // 869\n                                                                                 // 870\n      while (r--) {                                                              // 871\n        var points = getPointsAtRadius(maxRadius - r);                           // 872\n                                                                                 // 873\n        if (settings.shuffle) {                                                  // 874\n          points = [].concat(points);                                            // 875\n          shuffleArray(points);                                                  // 876\n        }                                                                        // 877\n                                                                                 // 878\n        // Try to fit the words by looking at each point.                        // 879\n        // array.some() will stop and return true                                // 880\n        // when putWordAtPoint() returns true.                                   // 881\n        // If all the points returns false, array.some() returns false.          // 882\n        var drawn = points.some(tryToPutWordAtPoint);                            // 883\n                                                                                 // 884\n        if (drawn) {                                                             // 885\n          // leave putWord() and return true                                     // 886\n          return true;                                                           // 887\n        }                                                                        // 888\n      }                                                                          // 889\n      // we tried all distances but text won't fit, return false                 // 890\n      return false;                                                              // 891\n    };                                                                           // 892\n                                                                                 // 893\n    /* Send DOM event to all elements. Will stop sending event and return        // 894\n       if the previous one is canceled (for cancelable events). */               // 895\n    var sendEvent = function sendEvent(type, cancelable, detail) {               // 896\n      if (cancelable) {                                                          // 897\n        return !elements.some(function(el) {                                     // 898\n          var evt = document.createEvent('CustomEvent');                         // 899\n          evt.initCustomEvent(type, true, cancelable, detail || {});             // 900\n          return !el.dispatchEvent(evt);                                         // 901\n        }, this);                                                                // 902\n      } else {                                                                   // 903\n        elements.forEach(function(el) {                                          // 904\n          var evt = document.createEvent('CustomEvent');                         // 905\n          evt.initCustomEvent(type, true, cancelable, detail || {});             // 906\n          el.dispatchEvent(evt);                                                 // 907\n        }, this);                                                                // 908\n      }                                                                          // 909\n    };                                                                           // 910\n                                                                                 // 911\n    /* Start drawing on a canvas */                                              // 912\n    var start = function start() {                                               // 913\n      // For dimensions, clearCanvas etc.,                                       // 914\n      // we only care about the first element.                                   // 915\n      var canvas = elements[0];                                                  // 916\n                                                                                 // 917\n      if (canvas.getContext) {                                                   // 918\n        ngx = Math.floor(canvas.width / g);                                      // 919\n        ngy = Math.floor(canvas.height / g);                                     // 920\n      } else {                                                                   // 921\n        var rect = canvas.getBoundingClientRect();                               // 922\n        ngx = Math.floor(rect.width / g);                                        // 923\n        ngy = Math.floor(rect.height / g);                                       // 924\n      }                                                                          // 925\n                                                                                 // 926\n      // Sending a wordcloudstart event which cause the previous loop to stop.   // 927\n      // Do nothing if the event is canceled.                                    // 928\n      if (!sendEvent('wordcloudstart', true)) {                                  // 929\n        return;                                                                  // 930\n      }                                                                          // 931\n                                                                                 // 932\n      // Determine the center of the word cloud                                  // 933\n      center = (settings.origin) ?                                               // 934\n        [settings.origin[0]/g, settings.origin[1]/g] :                           // 935\n        [ngx / 2, ngy / 2];                                                      // 936\n                                                                                 // 937\n      // Maxium radius to look for space                                         // 938\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));                  // 939\n                                                                                 // 940\n      /* Clear the canvas only if the clearCanvas is set,                        // 941\n         if not, update the grid to the current canvas state */                  // 942\n      grid = [];                                                                 // 943\n                                                                                 // 944\n      var gx, gy, i;                                                             // 945\n      if (!canvas.getContext || settings.clearCanvas) {                          // 946\n        elements.forEach(function(el) {                                          // 947\n          if (el.getContext) {                                                   // 948\n            var ctx = el.getContext('2d');                                       // 949\n            ctx.fillStyle = settings.backgroundColor;                            // 950\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));                   // 951\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));                    // 952\n          } else {                                                               // 953\n            el.textContent = '';                                                 // 954\n            el.style.backgroundColor = settings.backgroundColor;                 // 955\n          }                                                                      // 956\n        });                                                                      // 957\n                                                                                 // 958\n        /* fill the grid with empty state */                                     // 959\n        gx = ngx;                                                                // 960\n        while (gx--) {                                                           // 961\n          grid[gx] = [];                                                         // 962\n          gy = ngy;                                                              // 963\n          while (gy--) {                                                         // 964\n            grid[gx][gy] = true;                                                 // 965\n          }                                                                      // 966\n        }                                                                        // 967\n      } else {                                                                   // 968\n        /* Determine bgPixel by creating                                         // 969\n           another canvas and fill the specified background color. */            // 970\n        var bctx = document.createElement('canvas').getContext('2d');            // 971\n                                                                                 // 972\n        bctx.fillStyle = settings.backgroundColor;                               // 973\n        bctx.fillRect(0, 0, 1, 1);                                               // 974\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;                        // 975\n                                                                                 // 976\n        /* Read back the pixels of the canvas we got to tell which part of the   // 977\n           canvas is empty.                                                      // 978\n           (no clearCanvas only works with a canvas, not divs) */                // 979\n        var imageData =                                                          // 980\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;     // 981\n                                                                                 // 982\n        gx = ngx;                                                                // 983\n        var x, y;                                                                // 984\n        while (gx--) {                                                           // 985\n          grid[gx] = [];                                                         // 986\n          gy = ngy;                                                              // 987\n          while (gy--) {                                                         // 988\n            y = g;                                                               // 989\n            singleGridLoop: while (y--) {                                        // 990\n              x = g;                                                             // 991\n              while (x--) {                                                      // 992\n                i = 4;                                                           // 993\n                while (i--) {                                                    // 994\n                  if (imageData[((gy * g + y) * ngx * g +                        // 995\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {        // 996\n                    grid[gx][gy] = false;                                        // 997\n                    break singleGridLoop;                                        // 998\n                  }                                                              // 999\n                }                                                                // 1000\n              }                                                                  // 1001\n            }                                                                    // 1002\n            if (grid[gx][gy] !== false) {                                        // 1003\n              grid[gx][gy] = true;                                               // 1004\n            }                                                                    // 1005\n          }                                                                      // 1006\n        }                                                                        // 1007\n                                                                                 // 1008\n        imageData = bctx = bgPixel = undefined;                                  // 1009\n      }                                                                          // 1010\n                                                                                 // 1011\n      // fill the infoGrid with empty state if we need it                        // 1012\n      if (settings.hover || settings.click) {                                    // 1013\n                                                                                 // 1014\n        interactive = true;                                                      // 1015\n                                                                                 // 1016\n        /* fill the grid with empty state */                                     // 1017\n        gx = ngx + 1;                                                            // 1018\n        while (gx--) {                                                           // 1019\n          infoGrid[gx] = [];                                                     // 1020\n        }                                                                        // 1021\n                                                                                 // 1022\n        if (settings.hover) {                                                    // 1023\n          canvas.addEventListener('mousemove', wordcloudhover);                  // 1024\n        }                                                                        // 1025\n                                                                                 // 1026\n        if (settings.click) {                                                    // 1027\n          canvas.addEventListener('click', wordcloudclick);                      // 1028\n        }                                                                        // 1029\n                                                                                 // 1030\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {   // 1031\n          canvas.removeEventListener('wordcloudstart', stopInteraction);         // 1032\n                                                                                 // 1033\n          canvas.removeEventListener('mousemove', wordcloudhover);               // 1034\n          canvas.removeEventListener('click', wordcloudclick);                   // 1035\n          hovered = undefined;                                                   // 1036\n        });                                                                      // 1037\n      }                                                                          // 1038\n                                                                                 // 1039\n      i = 0;                                                                     // 1040\n      var loopingFunction, stoppingFunction;                                     // 1041\n      if (settings.wait !== 0) {                                                 // 1042\n        loopingFunction = window.setTimeout;                                     // 1043\n        stoppingFunction = window.clearTimeout;                                  // 1044\n      } else {                                                                   // 1045\n        loopingFunction = window.setImmediate;                                   // 1046\n        stoppingFunction = window.clearImmediate;                                // 1047\n      }                                                                          // 1048\n                                                                                 // 1049\n      var addEventListener = function addEventListener(type, listener) {         // 1050\n        elements.forEach(function(el) {                                          // 1051\n          el.addEventListener(type, listener);                                   // 1052\n        }, this);                                                                // 1053\n      };                                                                         // 1054\n                                                                                 // 1055\n      var removeEventListener = function removeEventListener(type, listener) {   // 1056\n        elements.forEach(function(el) {                                          // 1057\n          el.removeEventListener(type, listener);                                // 1058\n        }, this);                                                                // 1059\n      };                                                                         // 1060\n                                                                                 // 1061\n      var anotherWordCloudStart = function anotherWordCloudStart() {             // 1062\n        removeEventListener('wordcloudstart', anotherWordCloudStart);            // 1063\n        stoppingFunction(timer);                                                 // 1064\n      };                                                                         // 1065\n                                                                                 // 1066\n      addEventListener('wordcloudstart', anotherWordCloudStart);                 // 1067\n                                                                                 // 1068\n      var timer = loopingFunction(function loop() {                              // 1069\n        if (i >= settings.list.length) {                                         // 1070\n          stoppingFunction(timer);                                               // 1071\n          sendEvent('wordcloudstop', false);                                     // 1072\n          removeEventListener('wordcloudstart', anotherWordCloudStart);          // 1073\n                                                                                 // 1074\n          return;                                                                // 1075\n        }                                                                        // 1076\n        escapeTime = (new Date()).getTime();                                     // 1077\n        var drawn = putWord(settings.list[i]);                                   // 1078\n        var canceled = !sendEvent('wordclouddrawn', true, {                      // 1079\n          item: settings.list[i], drawn: drawn });                               // 1080\n        if (exceedTime() || canceled) {                                          // 1081\n          stoppingFunction(timer);                                               // 1082\n          settings.abort();                                                      // 1083\n          sendEvent('wordcloudabort', false);                                    // 1084\n          sendEvent('wordcloudstop', false);                                     // 1085\n          removeEventListener('wordcloudstart', anotherWordCloudStart);          // 1086\n          return;                                                                // 1087\n        }                                                                        // 1088\n        i++;                                                                     // 1089\n        timer = loopingFunction(loop, settings.wait);                            // 1090\n      }, settings.wait);                                                         // 1091\n    };                                                                           // 1092\n                                                                                 // 1093\n    // All set, start the drawing                                                // 1094\n    start();                                                                     // 1095\n  };                                                                             // 1096\n                                                                                 // 1097\n  WordCloud.isSupported = isSupported;                                           // 1098\n  WordCloud.miniumFontSize = miniumFontSize;                                     // 1099\n                                                                                 // 1100\n  // Expose the library as an AMD module                                         // 1101\n  if (typeof global.define === 'function' && global.define.amd) {                // 1102\n    global.define('wordcloud', [], function() { return WordCloud; });            // 1103\n  } else {                                                                       // 1104\n    global.WordCloud = WordCloud;                                                // 1105\n  }                                                                              // 1106\n                                                                                 // 1107\n})(window);                                                                      // 1108\n                                                                                 // 1109\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/overture8:wordcloud2/overture8:wordcloud2.js                         //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n// Write your package code here!                                                 // 1\n                                                                                 // 2\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}